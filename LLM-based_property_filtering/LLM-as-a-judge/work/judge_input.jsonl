{"custom_id": "AXI channel handshake", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5-2025-08-07", "instructions": "You are an expert in formal verification of System-on-Chip (SoC) designs. You will be provided with (1) a specification document of an on-chip communication protocol and (2) a list of LLM-generated SVA properties that describes a specific mechanism of the protocol. Categorize each LLM-generated properties with the following step:\n1. Irrelevent: Check if the property is not relevant, or does not describe any functionality (e.g., just checking signal width) of the target mechanism.\n2. Correct/Incorrect/Possible: For the remaining properties, check whether each of them is correct with respect to the specification document. If a property does not explicitly describe or violate any description from the document, categorize it as Possible.\n3. Redundant: For the Correct properties, identify whether each of them is redundant, which means removing them will not affect the functionality of the remaining correct list.\nLabel each property as either \"correct\", \"redundant\", \"incorrect\", \"possible\" or \"irrelevant\" by following the above steps.\nAdditionally, you will be provided with a manually-developed SVA property list as sample solutions. For each manually developed property, check if its constraint is covered by the LLM-generated list.\nFinally, identify any critical properties, if there's any, that are missing from the both the lists but are necessary to fully describe the target mechanism based on the specification document (description in natural language is fine). Do not try to \"strengthen\" existing properties by rewriting them. Focus on aspects where the existing properties do not cover.", "input": [{"role": "user", "content": [{"type": "input_file", "file_id": "file-8Kne7KXdhcgcvFpxwyAkZv"}, {"type": "input_text", "text": "// LLM-generated SVA properties for AXI channel handshake:\n// 1. If READY is LOW and VALID is HIGH, then VALID remains stable in the next cycle.\n(READY == 1'b0) && (VALID == 1'b1) |-> ##1 $stable(VALID)\n\n// 2. If READY is LOW and VALID is HIGH, then INFORMATION remains stable in the next cycle.\n(READY == 1'b0) && (VALID == 1'b1) |-> ##1 $stable(INFORMATION)\n\n\n// Manually-developed SVA properties:\n// 1. If READY is LOW and VALID is HIGH, then VALID remains stable in the next cycle.\n(READY == 1'b0) && (VALID == 1'b1) |-> ##1 $stable(VALID)\n\n// 2. If READY is LOW and VALID is HIGH, then INFORMATION remains stable in the next cycle.\n(READY == 1'b0) && (VALID == 1'b1) |-> ##1 $stable(INFORMATION)\n\n"}]}]}}
{"custom_id": "AXI reset", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5-2025-08-07", "instructions": "You are an expert in formal verification of System-on-Chip (SoC) designs. You will be provided with (1) a specification document of an on-chip communication protocol and (2) a list of LLM-generated SVA properties that describes a specific mechanism of the protocol. Categorize each LLM-generated properties with the following step:\n1. Irrelevent: Check if the property is not relevant, or does not describe any functionality (e.g., just checking signal width) of the target mechanism.\n2. Correct/Incorrect/Possible: For the remaining properties, check whether each of them is correct with respect to the specification document. If a property does not explicitly describe or violate any description from the document, categorize it as Possible.\n3. Redundant: For the Correct properties, identify whether each of them is redundant, which means removing them will not affect the functionality of the remaining correct list.\nLabel each property as either \"correct\", \"redundant\", \"incorrect\", \"possible\" or \"irrelevant\" by following the above steps.\nAdditionally, you will be provided with a manually-developed SVA property list as sample solutions. For each manually developed property, check if its constraint is covered by the LLM-generated list.\nFinally, identify any critical properties, if there's any, that are missing from the both the lists but are necessary to fully describe the target mechanism based on the specification document (description in natural language is fine). Do not try to \"strengthen\" existing properties by rewriting them. Focus on aspects where the existing properties do not cover.", "input": [{"role": "user", "content": [{"type": "input_file", "file_id": "file-8Kne7KXdhcgcvFpxwyAkZv"}, {"type": "input_text", "text": "// LLM-generated SVA properties for AXI reset:\n// 1. If ARESETn is LOW, then VALID is LOW.\n(ARESETn == 1'b0) |-> (VALID == 1'b0)\n\n// 2. If VALID is HIGH, then ARESETn is HIGH.\n(VALID == 1'b1) |-> (ARESETn == 1'b1)\n\n// 3. If ARESETn changes from LOW to HIGH, then VALID is LOW.\n$rose(ARESETn) |-> (VALID == 1'b0)\n\n// 4. If VALID changes from LOW to HIGH, then ARESETn is HIGH.\n$rose(VALID) |-> (ARESETn == 1'b1)\n\n\n// Manually-developed SVA properties:\n// 1. If ARESETn is LOW, then VALID is LOW.\n(ARESETn == 1'b0) |-> (VALID == 1'b0)\n\n// 2. If ARESETn changes from LOW to HIGH, then VALID is LOW.\n$rose(ARESETn) |-> (VALID == 1'b0)\n\n"}]}]}}
{"custom_id": "AXI low-power handshake", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5-2025-08-07", "instructions": "You are an expert in formal verification of System-on-Chip (SoC) designs. You will be provided with (1) a specification document of an on-chip communication protocol and (2) a list of LLM-generated SVA properties that describes a specific mechanism of the protocol. Categorize each LLM-generated properties with the following step:\n1. Irrelevent: Check if the property is not relevant, or does not describe any functionality (e.g., just checking signal width) of the target mechanism.\n2. Correct/Incorrect/Possible: For the remaining properties, check whether each of them is correct with respect to the specification document. If a property does not explicitly describe or violate any description from the document, categorize it as Possible.\n3. Redundant: For the Correct properties, identify whether each of them is redundant, which means removing them will not affect the functionality of the remaining correct list.\nLabel each property as either \"correct\", \"redundant\", \"incorrect\", \"possible\" or \"irrelevant\" by following the above steps.\nAdditionally, you will be provided with a manually-developed SVA property list as sample solutions. For each manually developed property, check if its constraint is covered by the LLM-generated list.\nFinally, identify any critical properties, if there's any, that are missing from the both the lists but are necessary to fully describe the target mechanism based on the specification document (description in natural language is fine). Do not try to \"strengthen\" existing properties by rewriting them. Focus on aspects where the existing properties do not cover.", "input": [{"role": "user", "content": [{"type": "input_file", "file_id": "file-8Kne7KXdhcgcvFpxwyAkZv"}, {"type": "input_text", "text": "// LLM-generated SVA properties for AXI low-power handshake:\n// 1. If CSYSREQ is LOW, then CSYSACK is LOW or CSYSREQ is LOW in the next cycle.\n(CSYSREQ == 1'b0) |-> ##1 (CSYSACK == 1'b0) || (CSYSREQ == 1'b0)\n\n// 2. If CSYSREQ is HIGH, then CSYSACK is HIGH or CSYSREQ is HIGH in the next cycle.\n(CSYSREQ == 1'b1) |-> ##1 (CSYSACK == 1'b1) || (CSYSREQ == 1'b1)\n\n// 3. If CSYSACK is LOW and CSYSREQ is LOW, then CSYSACK is LOW in the next cycle.\n(CSYSACK == 1'b0) && (CSYSREQ == 1'b0) |-> ##1 (CSYSACK == 1'b0)\n\n// 4. If CSYSACK is HIGH and CSYSREQ is HIGH, then CSYSACK is HIGH in the next cycle.\n(CSYSACK == 1'b1) && (CSYSREQ == 1'b1) |-> ##1 (CSYSACK == 1'b1)\n\n// 5. If CSYSACK changes from LOW to HIGH, then CSYSREQ is HIGH.\n$rose(CSYSACK) |-> (CSYSREQ == 1'b1)\n\n// 6. If CSYSACK changes from HIGH to LOW, then CSYSREQ is LOW.\n$fell(CSYSACK) |-> (CSYSREQ == 1'b0)\n\n// 7. If CSYSREQ changes from LOW to HIGH, then CSYSACK is HIGH eventually.\n$rose(CSYSREQ) |-> ##[0:$] (CSYSACK == 1'b1)\n\n// 8. If CSYSREQ changes from HIGH to LOW, then CSYSACK is LOW eventually.\n$fell(CSYSREQ) |-> ##[0:$] (CSYSACK == 1'b0)\n\n\n// Manually-developed SVA properties:\n// 1. If CSYSREQ changes from HIGH to LOW, then CSYSACK is HIGH.\n$fell(CSYSREQ) |-> (CSYSACK == 1'b1)\n\n// 2. If CSYSREQ changes from LOW to HIGH, then CSYSACK is LOW.\n$rose(CSYSREQ) |-> (CSYSACK == 1'b0)\n\n// 3. If CSYSACK changes from HIGH to LOW, then CSYSREQ is LOW.\n$fell(CSYSACK) |-> (CSYSREQ == 1'b0)\n\n// 4. If CSYSACK changes from LOW to HIGH, then CSYSREQ is HIGH.\n$rose(CSYSACK) |-> (CSYSREQ == 1'b1)\n\n"}]}]}}
{"custom_id": "Q-Channel handshake", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5-2025-08-07", "instructions": "You are an expert in formal verification of System-on-Chip (SoC) designs. You will be provided with (1) a specification document of an on-chip communication protocol and (2) a list of LLM-generated SVA properties that describes a specific mechanism of the protocol. Categorize each LLM-generated properties with the following step:\n1. Irrelevent: Check if the property is not relevant, or does not describe any functionality (e.g., just checking signal width) of the target mechanism.\n2. Correct/Incorrect/Possible: For the remaining properties, check whether each of them is correct with respect to the specification document. If a property does not explicitly describe or violate any description from the document, categorize it as Possible.\n3. Redundant: For the Correct properties, identify whether each of them is redundant, which means removing them will not affect the functionality of the remaining correct list.\nLabel each property as either \"correct\", \"redundant\", \"incorrect\", \"possible\" or \"irrelevant\" by following the above steps.\nAdditionally, you will be provided with a manually-developed SVA property list as sample solutions. For each manually developed property, check if its constraint is covered by the LLM-generated list.\nFinally, identify any critical properties, if there's any, that are missing from the both the lists but are necessary to fully describe the target mechanism based on the specification document (description in natural language is fine). Do not try to \"strengthen\" existing properties by rewriting them. Focus on aspects where the existing properties do not cover.", "input": [{"role": "user", "content": [{"type": "input_file", "file_id": "file-2aYovVdYj2zKMoHGVaSjaE"}, {"type": "input_text", "text": "// LLM-generated SVA properties for Q-Channel handshake:\n// 1. If QREQn changes from LOW to HIGH, then QACCEPTn is LOW or QDENY is HIGH.\n$rose(QREQn) |-> (QACCEPTn == 1'b0) || (QDENY == 1'b1)\n\n// 2. If QREQn changes from LOW to HIGH, then QACCEPTn is HIGH or QDENY is LOW.\n$rose(QREQn) |-> (QACCEPTn == 1'b1) || (QDENY == 1'b0)\n\n// 3. If QREQn changes from HIGH to LOW, then QACCEPTn is HIGH.\n$fell(QREQn) |-> (QACCEPTn == 1'b1)\n\n// 4. If QREQn changes from HIGH to LOW, then QDENY is LOW.\n$fell(QREQn) |-> (QDENY == 1'b0)\n\n// 5. If QACCEPTn changes from LOW to HIGH, then QREQn is HIGH.\n$rose(QACCEPTn) |-> (QREQn == 1'b1)\n\n// 6. If QACCEPTn changes from LOW to HIGH, then QDENY is LOW.\n$rose(QACCEPTn) |-> (QDENY == 1'b0)\n\n// 7. If QACCEPTn changes from HIGH to LOW, then QREQn is LOW.\n$fell(QACCEPTn) |-> (QREQn == 1'b0)\n\n// 8. If QACCEPTn changes from HIGH to LOW, then QDENY is LOW.\n$fell(QACCEPTn) |-> (QDENY == 1'b0)\n\n// 9. If QDENY changes from LOW to HIGH, then QREQn is LOW.\n$rose(QDENY) |-> (QREQn == 1'b0)\n\n// 10. If QDENY changes from LOW to HIGH, then QACCEPTn is HIGH.\n$rose(QDENY) |-> (QACCEPTn == 1'b1)\n\n// 11. If QDENY changes from HIGH to LOW, then QREQn is HIGH.\n$fell(QDENY) |-> (QREQn == 1'b1)\n\n// 12. If QDENY changes from HIGH to LOW, then QACCEPTn is HIGH.\n$fell(QDENY) |-> (QACCEPTn == 1'b1)\n\n// 13. If QACCEPTn is LOW, then QDENY is LOW.\n(QACCEPTn == 1'b0) |-> (QDENY == 1'b0)\n\n// 14. If QDENY is HIGH, then QACCEPTn is HIGH.\n(QDENY == 1'b1) |-> (QACCEPTn == 1'b1)\n\n\n// Manually-developed SVA properties:\n// 1. If QREQn changes from HIGH to LOW, then QACCEPTn is HIGH.\n$fell(QREQn) |-> (QACCEPTn == 1'b1)\n\n// 2. If QREQn changes from HIGH to LOW, then QDENY is LOW.\n$fell(QREQn) |-> (QDENY == 1'b0)\n\n// 3. If QREQn changes from LOW to HIGH, then QACCEPTn is LOW or QDENY is HIGH.\n$rose(QREQn) |-> (QACCEPTn == 1'b0) || (QDENY == 1'b1)\n\n// 4. If QREQn changes from LOW to HIGH, then QACCEPTn is HIGH or QDENY is LOW.\n$rose(QREQn) |-> (QACCEPTn == 1'b1) || (QDENY == 1'b0)\n\n// 5. If QACCEPTn changes from HIGH to LOW, then QREQn is LOW.\n$fell(QACCEPTn) |-> (QREQn == 1'b0)\n\n// 6. If QACCEPTn changes from HIGH to LOW, then QDENY is LOW.\n$fell(QACCEPTn) |-> (QDENY == 1'b0)\n\n// 7. If QACCEPTn changes from LOW to HIGH, then QREQn is HIGH.\n$rose(QACCEPTn) |-> (QREQn == 1'b1)\n\n// 8. If QACCEPTn changes from LOW to HIGH, then QDENY is LOW.\n$rose(QACCEPTn) |-> (QDENY == 1'b0)\n\n// 9. If QDENY changes from HIGH to LOW, then QREQn is HIGH.\n$fell(QDENY) |-> (QREQn == 1'b1)\n\n// 10. If QDENY changes from HIGH to LOW, then QACCEPTn is HIGH.\n$fell(QDENY) |-> (QACCEPTn == 1'b1)\n\n// 11. If QDENY changes from LOW to HIGH, then QREQn is LOW.\n$rose(QDENY) |-> (QREQn == 1'b0)\n\n// 12. If QDENY changes from LOW to HIGH, then QACCEPTn is HIGH.\n$rose(QDENY) |-> (QACCEPTn == 1'b1)\n\n"}]}]}}
{"custom_id": "Q-Channel reset", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5-2025-08-07", "instructions": "You are an expert in formal verification of System-on-Chip (SoC) designs. You will be provided with (1) a specification document of an on-chip communication protocol and (2) a list of LLM-generated SVA properties that describes a specific mechanism of the protocol. Categorize each LLM-generated properties with the following step:\n1. Irrelevent: Check if the property is not relevant, or does not describe any functionality (e.g., just checking signal width) of the target mechanism.\n2. Correct/Incorrect/Possible: For the remaining properties, check whether each of them is correct with respect to the specification document. If a property does not explicitly describe or violate any description from the document, categorize it as Possible.\n3. Redundant: For the Correct properties, identify whether each of them is redundant, which means removing them will not affect the functionality of the remaining correct list.\nLabel each property as either \"correct\", \"redundant\", \"incorrect\", \"possible\" or \"irrelevant\" by following the above steps.\nAdditionally, you will be provided with a manually-developed SVA property list as sample solutions. For each manually developed property, check if its constraint is covered by the LLM-generated list.\nFinally, identify any critical properties, if there's any, that are missing from the both the lists but are necessary to fully describe the target mechanism based on the specification document (description in natural language is fine). Do not try to \"strengthen\" existing properties by rewriting them. Focus on aspects where the existing properties do not cover.", "input": [{"role": "user", "content": [{"type": "input_file", "file_id": "file-2aYovVdYj2zKMoHGVaSjaE"}, {"type": "input_text", "text": "// LLM-generated SVA properties for Q-Channel reset:\n// 1. If RESETn is LOW, then QACCEPTn is LOW.\n(RESETn == 1'b0) |-> (QACCEPTn == 1'b0)\n\n// 2. If RESETn is LOW, then QDENY is LOW.\n(RESETn == 1'b0) |-> (QDENY == 1'b0)\n\n// 3. If RESETn changes from HIGH to LOW, then QREQn is LOW.\n$fell(RESETn) |-> (QREQn == 1'b0)\n\n// 4. If RESETn changes from HIGH to LOW, then QACCEPTn is LOW.\n$fell(RESETn) |-> (QACCEPTn == 1'b0)\n\n// 5. If RESETn changes from HIGH to LOW, then QDENY is LOW.\n$fell(RESETn) |-> (QDENY == 1'b0)\n\n// 6. If RESETn changes from LOW to HIGH, then QACCEPTn is LOW.\n$rose(RESETn) |-> (QACCEPTn == 1'b0)\n\n// 7. If RESETn changes from LOW to HIGH, then QDENY is LOW.\n$rose(RESETn) |-> (QDENY == 1'b0)\n\n\n// Manually-developed SVA properties:\n// 1. If RESETn is LOW, then QACCEPTn is LOW.\n(RESETn == 1'b0) |-> (QACCEPTn == 1'b0)\n\n// 2. If RESETn is LOW, then QDENY is LOW.\n(RESETn == 1'b0) |-> (QDENY == 1'b0)\n\n// 3. If RESETn changes from LOW to HIGH, then QACCEPTn is LOW.\n$rose(RESETn) |-> (QACCEPTn == 1'b0)\n\n// 4. If RESETn changes from LOW to HIGH, then QDENY is LOW.\n$rose(RESETn) |-> (QDENY == 1'b0)\n\n"}]}]}}
{"custom_id": "P-Channel handshake", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5-2025-08-07", "instructions": "You are an expert in formal verification of System-on-Chip (SoC) designs. You will be provided with (1) a specification document of an on-chip communication protocol and (2) a list of LLM-generated SVA properties that describes a specific mechanism of the protocol. Categorize each LLM-generated properties with the following step:\n1. Irrelevent: Check if the property is not relevant, or does not describe any functionality (e.g., just checking signal width) of the target mechanism.\n2. Correct/Incorrect/Possible: For the remaining properties, check whether each of them is correct with respect to the specification document. If a property does not explicitly describe or violate any description from the document, categorize it as Possible.\n3. Redundant: For the Correct properties, identify whether each of them is redundant, which means removing them will not affect the functionality of the remaining correct list.\nLabel each property as either \"correct\", \"redundant\", \"incorrect\", \"possible\" or \"irrelevant\" by following the above steps.\nAdditionally, you will be provided with a manually-developed SVA property list as sample solutions. For each manually developed property, check if its constraint is covered by the LLM-generated list.\nFinally, identify any critical properties, if there's any, that are missing from the both the lists but are necessary to fully describe the target mechanism based on the specification document (description in natural language is fine). Do not try to \"strengthen\" existing properties by rewriting them. Focus on aspects where the existing properties do not cover.", "input": [{"role": "user", "content": [{"type": "input_file", "file_id": "file-2aYovVdYj2zKMoHGVaSjaE"}, {"type": "input_text", "text": "// LLM-generated SVA properties for P-Channel handshake:\n// 1. If PACCEPT is HIGH, then PDENY is LOW.\n(PACCEPT == 1'b1) |-> (PDENY == 1'b0)\n\n// 2. If PDENY is HIGH, then PACCEPT is LOW.\n(PDENY == 1'b1) |-> (PACCEPT == 1'b0)\n\n// 3. If PACCEPT changes from LOW to HIGH, then PREQ is HIGH.\n$rose(PACCEPT) |-> (PREQ == 1'b1)\n\n// 4. If PACCEPT changes from LOW to HIGH, then PDENY is LOW.\n$rose(PACCEPT) |-> (PDENY == 1'b0)\n\n// 5. If PDENY changes from LOW to HIGH, then PREQ is HIGH.\n$rose(PDENY) |-> (PREQ == 1'b1)\n\n// 6. If PDENY changes from LOW to HIGH, then PACCEPT is LOW.\n$rose(PDENY) |-> (PACCEPT == 1'b0)\n\n// 7. If PACCEPT is HIGH and PREQ is HIGH, then PACCEPT remains stable in the next cycle.\n(PACCEPT == 1'b1) && (PREQ == 1'b1) |-> ##1 $stable(PACCEPT)\n\n// 8. If PDENY is HIGH and PREQ is HIGH, then PDENY remains stable in the next cycle.\n(PDENY == 1'b1) && (PREQ == 1'b1) |-> ##1 $stable(PDENY)\n\n// 9. If PACCEPT changes from HIGH to LOW, then PREQ is LOW.\n$fell(PACCEPT) |-> (PREQ == 1'b0)\n\n// 10. If PACCEPT changes from HIGH to LOW, then PDENY is LOW.\n$fell(PACCEPT) |-> (PDENY == 1'b0)\n\n// 11. If PDENY changes from HIGH to LOW, then PREQ is LOW.\n$fell(PDENY) |-> (PREQ == 1'b0)\n\n// 12. If PDENY changes from HIGH to LOW, then PACCEPT is LOW.\n$fell(PDENY) |-> (PACCEPT == 1'b0)\n\n// 13. If PREQ changes from LOW to HIGH, then PACCEPT is LOW.\n$rose(PREQ) |-> (PACCEPT == 1'b0)\n\n// 14. If PREQ changes from LOW to HIGH, then PDENY is LOW.\n$rose(PREQ) |-> (PDENY == 1'b0)\n\n// 15. If PREQ changes from HIGH to LOW, then PACCEPT is HIGH or PDENY is HIGH.\n$fell(PREQ) |-> (PACCEPT == 1'b1) || (PDENY == 1'b1)\n\n// 16. If PDENY is LOW and PREQ is HIGH, then PSTATE remains stable in the next cycle.\n(PDENY == 1'b0) && (PREQ == 1'b1) |-> ##1 $stable(PSTATE)\n\n// 17. If PACCEPT is HIGH, then PSTATE remains stable in the next cycle.\n(PACCEPT == 1'b1) |-> ##1 $stable(PSTATE)\n\n// 18. If PACCEPT is HIGH, then PDENY remains stable in the next cycle.\n(PACCEPT == 1'b1) |-> ##1 $stable(PDENY)\n\n// 19. If PDENY is HIGH, then PACCEPT remains stable in the next cycle.\n(PDENY == 1'b1) |-> ##1 $stable(PACCEPT)\n\n\n// Manually-developed SVA properties:\n// 1. If PREQ changes from LOW to HIGH, then PACCEPT is LOW.\n$rose(PREQ) |-> (PACCEPT == 1'b0)\n\n// 2. If PREQ changes from LOW to HIGH, then PDENY is LOW.\n$rose(PREQ) |-> (PDENY == 1'b0)\n\n// 3. If PREQ changes from HIGH to LOW, then PACCEPT is HIGH or PDENY is HIGH.\n$fell(PREQ) |-> (PACCEPT == 1'b1) || (PDENY == 1'b1)\n\n// 4. If PACCEPT changes from LOW to HIGH, then PREQ is HIGH.\n$rose(PACCEPT) |-> (PREQ == 1'b1)\n\n// 5. If PACCEPT changes from LOW to HIGH, then PDENY is LOW.\n$rose(PACCEPT) |-> (PDENY == 1'b0)\n\n// 6. If PACCEPT changes from HIGH to LOW, then PREQ is LOW.\n$fell(PACCEPT) |-> (PREQ == 1'b0)\n\n// 7. If PACCEPT changes from HIGH to LOW, then PDENY is LOW.\n$fell(PACCEPT) |-> (PDENY == 1'b0)\n\n// 8. If PDENY changes from LOW to HIGH, then PREQ is HIGH.\n$rose(PDENY) |-> (PREQ == 1'b1)\n\n// 9. If PDENY changes from LOW to HIGH, then PACCEPT is LOW.\n$rose(PDENY) |-> (PACCEPT == 1'b0)\n\n// 10. If PDENY changes from HIGH to LOW, then PREQ is LOW.\n$fell(PDENY) |-> (PREQ == 1'b0)\n\n// 11. If PDENY changes from HIGH to LOW, then PACCEPT is LOW.\n$fell(PDENY) |-> (PACCEPT == 1'b0)\n\n// 12. If PDENY is LOW and PREQ is HIGH, then PSTATE remains stable in the next cycle.\n(PDENY == 1'b0) && (PREQ == 1'b1) |-> ##1 $stable(PSTATE)\n\n// 13. If PACCEPT is HIGH and PREQ is LOW, then PSTATE remains stable in the next cycle.\n(PACCEPT == 1'b1) && (PREQ == 1'b0) |-> ##1 $stable(PSTATE)\n\n// 14. If PDENY is HIGH and PREQ is LOW, then PSTATE remains stable in the next cycle.\n(PDENY == 1'b1) && (PREQ == 1'b0) |-> ##1 $stable(PSTATE)\n\n"}]}]}}
{"custom_id": "P-Channel reset", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5-2025-08-07", "instructions": "You are an expert in formal verification of System-on-Chip (SoC) designs. You will be provided with (1) a specification document of an on-chip communication protocol and (2) a list of LLM-generated SVA properties that describes a specific mechanism of the protocol. Categorize each LLM-generated properties with the following step:\n1. Irrelevent: Check if the property is not relevant, or does not describe any functionality (e.g., just checking signal width) of the target mechanism.\n2. Correct/Incorrect/Possible: For the remaining properties, check whether each of them is correct with respect to the specification document. If a property does not explicitly describe or violate any description from the document, categorize it as Possible.\n3. Redundant: For the Correct properties, identify whether each of them is redundant, which means removing them will not affect the functionality of the remaining correct list.\nLabel each property as either \"correct\", \"redundant\", \"incorrect\", \"possible\" or \"irrelevant\" by following the above steps.\nAdditionally, you will be provided with a manually-developed SVA property list as sample solutions. For each manually developed property, check if its constraint is covered by the LLM-generated list.\nFinally, identify any critical properties, if there's any, that are missing from the both the lists but are necessary to fully describe the target mechanism based on the specification document (description in natural language is fine). Do not try to \"strengthen\" existing properties by rewriting them. Focus on aspects where the existing properties do not cover.", "input": [{"role": "user", "content": [{"type": "input_file", "file_id": "file-2aYovVdYj2zKMoHGVaSjaE"}, {"type": "input_text", "text": "// LLM-generated SVA properties for P-Channel reset:\n// 1. If RESETn is LOW, then PACCEPT is LOW.\n(RESETn == 1'b0) |-> (PACCEPT == 1'b0)\n\n// 2. If RESETn is LOW, then PDENY is LOW.\n(RESETn == 1'b0) |-> (PDENY == 1'b0)\n\n// 3. If RESETn changes from LOW to HIGH, then PACCEPT is LOW.\n$rose(RESETn) |-> (PACCEPT == 1'b0)\n\n// 4. If RESETn changes from LOW to HIGH, then PDENY is LOW.\n$rose(RESETn) |-> (PDENY == 1'b0)\n\n// 5. If RESETn changes from HIGH to LOW, then PACCEPT is LOW.\n$fell(RESETn) |-> (PACCEPT == 1'b0)\n\n// 6. If RESETn changes from HIGH to LOW, then PDENY is LOW.\n$fell(RESETn) |-> (PDENY == 1'b0)\n\n\n// Manually-developed SVA properties:\n// 1. If RESETn is LOW, then PACCEPT is LOW.\n(RESETn == 1'b0) |-> (PACCEPT == 1'b0)\n\n// 2. If RESETn is LOW, then PDENY is LOW.\n(RESETn == 1'b0) |-> (PDENY == 1'b0)\n\n// 3. If RESETn changes from LOW to HIGH, then PACCEPT is LOW.\n$rose(RESETn) |-> (PACCEPT == 1'b0)\n\n// 4. If RESETn changes from LOW to HIGH, then PDENY is LOW.\n$rose(RESETn) |-> (PDENY == 1'b0)\n\n"}]}]}}
{"custom_id": "WISHBONE data transfer", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5-2025-08-07", "instructions": "You are an expert in formal verification of System-on-Chip (SoC) designs. You will be provided with (1) a specification document of an on-chip communication protocol and (2) a list of LLM-generated SVA properties that describes a specific mechanism of the protocol. Categorize each LLM-generated properties with the following step:\n1. Irrelevent: Check if the property is not relevant, or does not describe any functionality (e.g., just checking signal width) of the target mechanism.\n2. Correct/Incorrect/Possible: For the remaining properties, check whether each of them is correct with respect to the specification document. If a property does not explicitly describe or violate any description from the document, categorize it as Possible.\n3. Redundant: For the Correct properties, identify whether each of them is redundant, which means removing them will not affect the functionality of the remaining correct list.\nLabel each property as either \"correct\", \"redundant\", \"incorrect\", \"possible\" or \"irrelevant\" by following the above steps.\nAdditionally, you will be provided with a manually-developed SVA property list as sample solutions. For each manually developed property, check if its constraint is covered by the LLM-generated list.\nFinally, identify any critical properties, if there's any, that are missing from the both the lists but are necessary to fully describe the target mechanism based on the specification document (description in natural language is fine). Do not try to \"strengthen\" existing properties by rewriting them. Focus on aspects where the existing properties do not cover.", "input": [{"role": "user", "content": [{"type": "input_file", "file_id": "file-6GrhLfg6bBETVfokhxvAia"}, {"type": "input_text", "text": "// LLM-generated SVA properties for WISHBONE data transfer:\n// 1. If STB_O changes from LOW to HIGH, then CYC_O is HIGH.\n$rose(STB_O) |-> (CYC_O == 1'b1)\n\n// 2. If STB_O is HIGH, then CYC_O is HIGH.\n(STB_O == 1'b1) |-> (CYC_O == 1'b1)\n\n// 3. If CYC_O is LOW, then STB_O is LOW.\n(CYC_O == 1'b0) |-> (STB_O == 1'b0)\n\n// 4. If CYC_O changes from HIGH to LOW, then STB_O is LOW.\n$fell(CYC_O) |-> (STB_O == 1'b0)\n\n// 5. If ACK_I is LOW and STB_O is HIGH, then STB_O is HIGH in the next cycle.\n(ACK_I == 1'b0) && (STB_O == 1'b1) |-> ##1 (STB_O == 1'b1)\n\n// 6. If ACK_I is LOW and STB_O is HIGH, then CYC_O is HIGH in the next cycle.\n(ACK_I == 1'b0) && (STB_O == 1'b1) |-> ##1 (CYC_O == 1'b1)\n\n// 7. If ACK_I is LOW and STB_O is HIGH, then WE_O remains stable in the next cycle.\n(ACK_I == 1'b0) && (STB_O == 1'b1) |-> ##1 $stable(WE_O)\n\n// 8. If ACK_I is LOW and STB_O is HIGH, then ADR_O remains stable in the next cycle.\n(ACK_I == 1'b0) && (STB_O == 1'b1) |-> ##1 $stable(ADR_O)\n\n// 9. If ACK_I is LOW and STB_O is HIGH, then SEL_O remains stable in the next cycle.\n(ACK_I == 1'b0) && (STB_O == 1'b1) |-> ##1 $stable(SEL_O)\n\n// 10. If ACK_I is LOW and STB_O is HIGH and WE_O is HIGH, then DAT_O remains stable in the next cycle.\n(ACK_I == 1'b0) && (STB_O == 1'b1) && (WE_O == 1'b1) |-> ##1 $stable(DAT_O)\n\n// 11. If ACK_I changes from LOW to HIGH, then STB_O is LOW eventually.\n$rose(ACK_I) |-> ##[0:$] (STB_O == 1'b0)\n\n\n// Manually-developed SVA properties:\n// 1. If STB_O is HIGH, then CYC_O is HIGH.\n(STB_O == 1'b1) |-> (CYC_O == 1'b1)\n\n// 2. If ACK_I is LOW and STB_O is HIGH, then STB_O remains stable in the next cycle.\n(ACK_I == 1'b0) && (STB_O == 1'b1) |-> ##1 $stable(STB_O)\n\n// 3. If ACK_I is LOW and STB_O is HIGH, then WE_O remains stable in the next cycle.\n(ACK_I == 1'b0) && (STB_O == 1'b1) |-> ##1 $stable(WE_O)\n\n// 4. If ACK_I is LOW and STB_O is HIGH, then ADR_O remains stable in the next cycle.\n(ACK_I == 1'b0) && (STB_O == 1'b1) |-> ##1 $stable(ADR_O)\n\n// 5. If ACK_I is LOW and STB_O is HIGH, then SEL_O remains stable in the next cycle.\n(ACK_I == 1'b0) && (STB_O == 1'b1) |-> ##1 $stable(SEL_O)\n\n// 6. If ACK_I is LOW and STB_O is HIGH and WE_O is HIGH, then DAT_O remains stable in the next cycle.\n(ACK_I == 1'b0) && (STB_O == 1'b1) && (WE_O == 1'b1) |-> ##1 $stable(DAT_O)\n\n// 7. If STB_O changes from LOW to HIGH, then ACK_I is HIGH eventually.\n$rose(STB_O) |-> ##[0:$] (ACK_I == 1'b1)\n\n// 8. If ACK_I is HIGH, then CYC_O is HIGH.\n(ACK_I == 1'b1) |-> (CYC_O == 1'b1)\n\n// 9. If ACK_I changes from LOW to HIGH, then STB_O is LOW eventually.\n$rose(ACK_I) |-> ##[0:$] (STB_O == 1'b0)\n\n"}]}]}}
{"custom_id": "WISHBONE reset", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5-2025-08-07", "instructions": "You are an expert in formal verification of System-on-Chip (SoC) designs. You will be provided with (1) a specification document of an on-chip communication protocol and (2) a list of LLM-generated SVA properties that describes a specific mechanism of the protocol. Categorize each LLM-generated properties with the following step:\n1. Irrelevent: Check if the property is not relevant, or does not describe any functionality (e.g., just checking signal width) of the target mechanism.\n2. Correct/Incorrect/Possible: For the remaining properties, check whether each of them is correct with respect to the specification document. If a property does not explicitly describe or violate any description from the document, categorize it as Possible.\n3. Redundant: For the Correct properties, identify whether each of them is redundant, which means removing them will not affect the functionality of the remaining correct list.\nLabel each property as either \"correct\", \"redundant\", \"incorrect\", \"possible\" or \"irrelevant\" by following the above steps.\nAdditionally, you will be provided with a manually-developed SVA property list as sample solutions. For each manually developed property, check if its constraint is covered by the LLM-generated list.\nFinally, identify any critical properties, if there's any, that are missing from the both the lists but are necessary to fully describe the target mechanism based on the specification document (description in natural language is fine). Do not try to \"strengthen\" existing properties by rewriting them. Focus on aspects where the existing properties do not cover.", "input": [{"role": "user", "content": [{"type": "input_file", "file_id": "file-6GrhLfg6bBETVfokhxvAia"}, {"type": "input_text", "text": "// LLM-generated SVA properties for WISHBONE reset:\n// 1. If RST_I is HIGH, then STB_O is LOW in the next cycle.\n(RST_I == 1'b1) |-> ##1 (STB_O == 1'b0)\n\n// 2. If RST_I is HIGH, then CYC_O is LOW in the next cycle.\n(RST_I == 1'b1) |-> ##1 (CYC_O == 1'b0)\n\n// 3. If RST_I changes from HIGH to LOW, then STB_O is LOW.\n$fell(RST_I) |-> (STB_O == 1'b0)\n\n// 4. If RST_I changes from HIGH to LOW, then CYC_O is LOW.\n$fell(RST_I) |-> (CYC_O == 1'b0)\n\n\n// Manually-developed SVA properties:\n// 1. If RST_I is HIGH, then STB_O is LOW in the next cycle.\n(RST_I == 1'b1) |-> ##1 (STB_O == 1'b0)\n\n// 2. If RST_I is HIGH, then CYC_O is LOW in the next cycle.\n(RST_I == 1'b1) |-> ##1 (CYC_O == 1'b0)\n\n"}]}]}}
{"custom_id": "APB transfers", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5-2025-08-07", "instructions": "You are an expert in formal verification of System-on-Chip (SoC) designs. You will be provided with (1) a specification document of an on-chip communication protocol and (2) a list of LLM-generated SVA properties that describes a specific mechanism of the protocol. Categorize each LLM-generated properties with the following step:\n1. Irrelevent: Check if the property is not relevant, or does not describe any functionality (e.g., just checking signal width) of the target mechanism.\n2. Correct/Incorrect/Possible: For the remaining properties, check whether each of them is correct with respect to the specification document. If a property does not explicitly describe or violate any description from the document, categorize it as Possible.\n3. Redundant: For the Correct properties, identify whether each of them is redundant, which means removing them will not affect the functionality of the remaining correct list.\nLabel each property as either \"correct\", \"redundant\", \"incorrect\", \"possible\" or \"irrelevant\" by following the above steps.\nAdditionally, you will be provided with a manually-developed SVA property list as sample solutions. For each manually developed property, check if its constraint is covered by the LLM-generated list.\nFinally, identify any critical properties, if there's any, that are missing from the both the lists but are necessary to fully describe the target mechanism based on the specification document (description in natural language is fine). Do not try to \"strengthen\" existing properties by rewriting them. Focus on aspects where the existing properties do not cover.", "input": [{"role": "user", "content": [{"type": "input_file", "file_id": "file-H3ftP5n325ZE8i9dgHSSpM"}, {"type": "input_text", "text": "// LLM-generated SVA properties for APB transfers:\n// 1. If PSEL changes from LOW to HIGH, then PENABLE is LOW.\n$rose(PSEL) |-> (PENABLE == 1'b0)\n\n// 2. If PENABLE is LOW and PSEL is HIGH, then PENABLE is HIGH in the next cycle.\n(PENABLE == 1'b0) && (PSEL == 1'b1) |-> ##1 (PENABLE == 1'b1)\n\n// 3. If PENABLE is LOW and PSEL is HIGH, then PSEL remains stable in the next cycle.\n(PENABLE == 1'b0) && (PSEL == 1'b1) |-> ##1 $stable(PSEL)\n\n// 4. If PENABLE is LOW and PSEL is HIGH, then PWRITE remains stable in the next cycle.\n(PENABLE == 1'b0) && (PSEL == 1'b1) |-> ##1 $stable(PWRITE)\n\n// 5. If PENABLE is LOW and PSEL is HIGH, then PADDR remains stable in the next cycle.\n(PENABLE == 1'b0) && (PSEL == 1'b1) |-> ##1 $stable(PADDR)\n\n// 6. If PENABLE is LOW and PSEL is HIGH and PWRITE is HIGH, then PWDATA remains stable in the next cycle.\n(PENABLE == 1'b0) && (PSEL == 1'b1) && (PWRITE == 1'b1) |-> ##1 $stable(PWDATA)\n\n// 7. If PENABLE is HIGH and PREADY is LOW and PSEL is HIGH, then PSEL remains stable in the next cycle.\n(PENABLE == 1'b1) && (PREADY == 1'b0) && (PSEL == 1'b1) |-> ##1 $stable(PSEL)\n\n// 8. If PENABLE is HIGH and PREADY is LOW and PSEL is HIGH, then PENABLE remains stable in the next cycle.\n(PENABLE == 1'b1) && (PREADY == 1'b0) && (PSEL == 1'b1) |-> ##1 $stable(PENABLE)\n\n// 9. If PENABLE is HIGH and PREADY is LOW and PSEL is HIGH, then PWRITE remains stable in the next cycle.\n(PENABLE == 1'b1) && (PREADY == 1'b0) && (PSEL == 1'b1) |-> ##1 $stable(PWRITE)\n\n// 10. If PENABLE is HIGH and PREADY is LOW and PSEL is HIGH, then PADDR remains stable in the next cycle.\n(PENABLE == 1'b1) && (PREADY == 1'b0) && (PSEL == 1'b1) |-> ##1 $stable(PADDR)\n\n// 11. If PREADY is LOW and PSEL is HIGH and PWRITE is HIGH, then PWDATA remains stable in the next cycle.\n(PREADY == 1'b0) && (PSEL == 1'b1) && (PWRITE == 1'b1) |-> ##1 $stable(PWDATA)\n\n\n// Manually-developed SVA properties:\n// 1. If PSEL changes from LOW to HIGH, then PENABLE is LOW.\n$rose(PSEL) |-> (PENABLE == 1'b0)\n\n// 2. If PENABLE is LOW and PSEL is HIGH, then PSEL remains stable in the next cycle.\n(PENABLE == 1'b0) && (PSEL == 1'b1) |-> ##1 $stable(PSEL)\n\n// 3. If PENABLE is LOW and PSEL is HIGH, then PWRITE remains stable in the next cycle.\n(PENABLE == 1'b0) && (PSEL == 1'b1) |-> ##1 $stable(PWRITE)\n\n// 4. If PENABLE is LOW and PSEL is HIGH, then PADDR remains stable in the next cycle.\n(PENABLE == 1'b0) && (PSEL == 1'b1) |-> ##1 $stable(PADDR)\n\n// 5. If PENABLE is LOW and PSEL is HIGH and PWRITE is HIGH, then PWDATA remains stable in the next cycle.\n(PENABLE == 1'b0) && (PSEL == 1'b1) && (PWRITE == 1'b1) |-> ##1 $stable(PWDATA)\n\n// 6. If PENABLE is LOW and PSEL is HIGH, then PENABLE is HIGH in the next cycle.\n(PENABLE == 1'b0) && (PSEL == 1'b1) |-> ##1 (PENABLE == 1'b1)\n\n// 7. If PENABLE is HIGH and PREADY is LOW and PSEL is HIGH, then PSEL remains stable in the next cycle.\n(PENABLE == 1'b1) && (PREADY == 1'b0) && (PSEL == 1'b1) |-> ##1 $stable(PSEL)\n\n// 8. If PENABLE is HIGH and PREADY is LOW and PSEL is HIGH, then PENABLE remains stable in the next cycle.\n(PENABLE == 1'b1) && (PREADY == 1'b0) && (PSEL == 1'b1) |-> ##1 $stable(PENABLE)\n\n// 9. If PENABLE is HIGH and PREADY is LOW and PSEL is HIGH, then PWRITE remains stable in the next cycle.\n(PENABLE == 1'b1) && (PREADY == 1'b0) && (PSEL == 1'b1) |-> ##1 $stable(PWRITE)\n\n// 10. If PENABLE is HIGH and PREADY is LOW and PSEL is HIGH, then PADDR remains stable in the next cycle.\n(PENABLE == 1'b1) && (PREADY == 1'b0) && (PSEL == 1'b1) |-> ##1 $stable(PADDR)\n\n// 11. If PREADY is LOW and PSEL is HIGH and PWRITE is HIGH, then PWDATA remains stable in the next cycle.\n(PREADY == 1'b0) && (PSEL == 1'b1) && (PWRITE == 1'b1) |-> ##1 $stable(PWDATA)\n\n// 12. If PENABLE is HIGH and PREADY is HIGH, then PENABLE is LOW or PSEL is LOW in the next cycle.\n(PENABLE == 1'b1) && (PREADY == 1'b1) |-> ##1 (PENABLE == 1'b0) || (PSEL == 1'b0)\n\n"}]}]}}
{"custom_id": "PCI transaction termination", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5-2025-08-07", "instructions": "You are an expert in formal verification of System-on-Chip (SoC) designs. You will be provided with (1) a specification document of an on-chip communication protocol and (2) a list of LLM-generated SVA properties that describes a specific mechanism of the protocol. Categorize each LLM-generated properties with the following step:\n1. Irrelevent: Check if the property is not relevant, or does not describe any functionality (e.g., just checking signal width) of the target mechanism.\n2. Correct/Incorrect/Possible: For the remaining properties, check whether each of them is correct with respect to the specification document. If a property does not explicitly describe or violate any description from the document, categorize it as Possible.\n3. Redundant: For the Correct properties, identify whether each of them is redundant, which means removing them will not affect the functionality of the remaining correct list.\nLabel each property as either \"correct\", \"redundant\", \"incorrect\", \"possible\" or \"irrelevant\" by following the above steps.\nAdditionally, you will be provided with a manually-developed SVA property list as sample solutions. For each manually developed property, check if its constraint is covered by the LLM-generated list.\nFinally, identify any critical properties, if there's any, that are missing from the both the lists but are necessary to fully describe the target mechanism based on the specification document (description in natural language is fine). Do not try to \"strengthen\" existing properties by rewriting them. Focus on aspects where the existing properties do not cover.", "input": [{"role": "user", "content": [{"type": "input_file", "file_id": "file-AXsE1uiqqH6UyzLDzgtdQw"}, {"type": "input_text", "text": "// LLM-generated SVA properties for PCI transaction termination:\n// 1. If FRAME# changes from LOW to HIGH, then IRDY# is LOW.\n$rose(FRAME#) |-> (IRDY# == 1'b0)\n\n// 2. If FRAME# changes from LOW to HIGH, then IRDY# is HIGH eventually.\n$rose(FRAME#) |-> ##[0:$] (IRDY# == 1'b1)\n\n// 3. If TRDY# is LOW, then DEVSEL# is LOW.\n(TRDY# == 1'b0) |-> (DEVSEL# == 1'b0)\n\n// 4. If TRDY# changes from HIGH to LOW, then DEVSEL# is LOW.\n$fell(TRDY#) |-> (DEVSEL# == 1'b0)\n\n// 5. If IRDY# is HIGH and TRDY# is LOW, then TRDY# remains stable in the next cycle.\n(IRDY# == 1'b1) && (TRDY# == 1'b0) |-> ##1 $stable(TRDY#)\n\n// 6. If IRDY# is HIGH and TRDY# is LOW, then DEVSEL# remains stable in the next cycle.\n(IRDY# == 1'b1) && (TRDY# == 1'b0) |-> ##1 $stable(DEVSEL#)\n\n// 7. If IRDY# is HIGH and STOP# is LOW, then STOP# remains stable in the next cycle.\n(IRDY# == 1'b1) && (STOP# == 1'b0) |-> ##1 $stable(STOP#)\n\n// 8. If IRDY# is HIGH and STOP# is LOW, then DEVSEL# remains stable in the next cycle.\n(IRDY# == 1'b1) && (STOP# == 1'b0) |-> ##1 $stable(DEVSEL#)\n\n// 9. If FRAME# is LOW and STOP# is LOW, then STOP# remains stable in the next cycle.\n(FRAME# == 1'b0) && (STOP# == 1'b0) |-> ##1 $stable(STOP#)\n\n// 10. If STOP# changes from LOW to HIGH, then FRAME# is HIGH.\n$rose(STOP#) |-> (FRAME# == 1'b1)\n\n\n// Manually-developed SVA properties:\n// 1. If FRAME# changes from LOW to HIGH, then IRDY# is LOW.\n$rose(FRAME#) |-> (IRDY# == 1'b0)\n\n// 2. If IRDY# is LOW and STOP# is HIGH and TRDY# is HIGH, then IRDY# remains stable in the next cycle.\n(IRDY# == 1'b0) && (STOP# == 1'b1) && (TRDY# == 1'b1) |-> ##1 $stable(IRDY#)\n\n// 3. If IRDY# is LOW and STOP# is HIGH and TRDY# is HIGH, then FRAME# remains stable in the next cycle.\n(IRDY# == 1'b0) && (STOP# == 1'b1) && (TRDY# == 1'b1) |-> ##1 $stable(FRAME#)\n\n// 4. If FRAME# is HIGH and IRDY# is LOW and TRDY# is LOW, then IRDY# is HIGH in the next cycle.\n(FRAME# == 1'b1) && (IRDY# == 1'b0) && (TRDY# == 1'b0) |-> ##1 (IRDY# == 1'b1)\n\n// 5. If FRAME# is HIGH and IRDY# is LOW and STOP# is LOW, then IRDY# is HIGH in the next cycle.\n(FRAME# == 1'b1) && (IRDY# == 1'b0) && (STOP# == 1'b0) |-> ##1 (IRDY# == 1'b1)\n\n// 6. If FRAME# is LOW and STOP# is LOW, then STOP# remains stable in the next cycle.\n(FRAME# == 1'b0) && (STOP# == 1'b0) |-> ##1 $stable(STOP#)\n\n// 7. If FRAME# is HIGH and STOP# is LOW, then STOP# is HIGH in the next cycle.\n(FRAME# == 1'b1) && (STOP# == 1'b0) |-> ##1 (STOP# == 1'b1)\n\n// 8. If IRDY# is HIGH and TRDY# is LOW, then TRDY# remains stable in the next cycle.\n(IRDY# == 1'b1) && (TRDY# == 1'b0) |-> ##1 $stable(TRDY#)\n\n// 9. If IRDY# is HIGH and TRDY# is LOW, then STOP# remains stable in the next cycle.\n(IRDY# == 1'b1) && (TRDY# == 1'b0) |-> ##1 $stable(STOP#)\n\n// 10. If IRDY# is HIGH and TRDY# is LOW, then DEVSEL# remains stable in the next cycle.\n(IRDY# == 1'b1) && (TRDY# == 1'b0) |-> ##1 $stable(DEVSEL#)\n\n// 11. If IRDY# is HIGH and STOP# is LOW, then TRDY# remains stable in the next cycle.\n(IRDY# == 1'b1) && (STOP# == 1'b0) |-> ##1 $stable(TRDY#)\n\n// 12. If IRDY# is HIGH and STOP# is LOW, then STOP# remains stable in the next cycle.\n(IRDY# == 1'b1) && (STOP# == 1'b0) |-> ##1 $stable(STOP#)\n\n// 13. If IRDY# is HIGH and STOP# is LOW, then DEVSEL# remains stable in the next cycle.\n(IRDY# == 1'b1) && (STOP# == 1'b0) |-> ##1 $stable(DEVSEL#)\n\n// 14. If STOP# is LOW, then FRAME# is HIGH or IRDY# is HIGH in the next cycle.\n(STOP# == 1'b0) |-> ##1 (FRAME# == 1'b1) || (IRDY# == 1'b1)\n\n// 15. If FRAME# is HIGH and IRDY# is LOW and TRDY# is LOW, then TRDY# is HIGH in the next cycle.\n(FRAME# == 1'b1) && (IRDY# == 1'b0) && (TRDY# == 1'b0) |-> ##1 (TRDY# == 1'b1)\n\n// 16. If FRAME# is HIGH and IRDY# is LOW and TRDY# is LOW, then STOP# is HIGH in the next cycle.\n(FRAME# == 1'b1) && (IRDY# == 1'b0) && (TRDY# == 1'b0) |-> ##1 (STOP# == 1'b1)\n\n// 17. If FRAME# is HIGH and IRDY# is LOW and TRDY# is LOW, then DEVSEL# is HIGH in the next cycle.\n(FRAME# == 1'b1) && (IRDY# == 1'b0) && (TRDY# == 1'b0) |-> ##1 (DEVSEL# == 1'b1)\n\n// 18. If FRAME# is HIGH and IRDY# is LOW and STOP# is LOW, then TRDY# is HIGH in the next cycle.\n(FRAME# == 1'b1) && (IRDY# == 1'b0) && (STOP# == 1'b0) |-> ##1 (TRDY# == 1'b1)\n\n// 19. If FRAME# is HIGH and IRDY# is LOW and STOP# is LOW, then STOP# is HIGH in the next cycle.\n(FRAME# == 1'b1) && (IRDY# == 1'b0) && (STOP# == 1'b0) |-> ##1 (STOP# == 1'b1)\n\n// 20. If FRAME# is HIGH and IRDY# is LOW and STOP# is LOW, then DEVSEL# is HIGH in the next cycle.\n(FRAME# == 1'b1) && (IRDY# == 1'b0) && (STOP# == 1'b0) |-> ##1 (DEVSEL# == 1'b1)\n\n"}]}]}}
{"custom_id": "PCI transaction termination batching", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5-2025-08-07", "instructions": "You are an expert in formal verification of System-on-Chip (SoC) designs. You will be provided with (1) a specification document of an on-chip communication protocol and (2) a list of LLM-generated SVA properties that describes a specific mechanism of the protocol. Categorize each LLM-generated properties with the following step:\n1. Irrelevent: Check if the property is not relevant, or does not describe any functionality (e.g., just checking signal width) of the target mechanism.\n2. Correct/Incorrect/Possible: For the remaining properties, check whether each of them is correct with respect to the specification document. If a property does not explicitly describe or violate any description from the document, categorize it as Possible.\n3. Redundant: For the Correct properties, identify whether each of them is redundant, which means removing them will not affect the functionality of the remaining correct list.\nLabel each property as either \"correct\", \"redundant\", \"incorrect\", \"possible\" or \"irrelevant\" by following the above steps.\nAdditionally, you will be provided with a manually-developed SVA property list as sample solutions. For each manually developed property, check if its constraint is covered by the LLM-generated list.\nFinally, identify any critical properties, if there's any, that are missing from the both the lists but are necessary to fully describe the target mechanism based on the specification document (description in natural language is fine). Do not try to \"strengthen\" existing properties by rewriting them. Focus on aspects where the existing properties do not cover.", "input": [{"role": "user", "content": [{"type": "input_file", "file_id": "file-AXsE1uiqqH6UyzLDzgtdQw"}, {"type": "input_text", "text": "// LLM-generated SVA properties for PCI transaction termination batching:\n// 1. If IRDY# is HIGH and TRDY# is LOW, then TRDY# remains stable in the next cycle.\n(IRDY# == 1'b1) && (TRDY# == 1'b0) |-> ##1 $stable(TRDY#)\n\n// 2. If IRDY# is HIGH and TRDY# is LOW, then DEVSEL# remains stable in the next cycle.\n(IRDY# == 1'b1) && (TRDY# == 1'b0) |-> ##1 $stable(DEVSEL#)\n\n// 3. If TRDY# changes from HIGH to LOW, then DEVSEL# is LOW.\n$fell(TRDY#) |-> (DEVSEL# == 1'b0)\n\n// 4. If FRAME# is HIGH and STOP# is LOW, then STOP# is HIGH in the next cycle.\n(FRAME# == 1'b1) && (STOP# == 1'b0) |-> ##1 (STOP# == 1'b1)\n\n// 5. If FRAME# is LOW and STOP# is LOW, then STOP# remains stable in the next cycle.\n(FRAME# == 1'b0) && (STOP# == 1'b0) |-> ##1 $stable(STOP#)\n\n// 6. If STOP# is LOW and TRDY# is HIGH, then TRDY# remains stable in the next cycle.\n(STOP# == 1'b0) && (TRDY# == 1'b1) |-> ##1 $stable(TRDY#)\n\n// 7. If IRDY# is HIGH and STOP# is LOW, then TRDY# remains stable in the next cycle.\n(IRDY# == 1'b1) && (STOP# == 1'b0) |-> ##1 $stable(TRDY#)\n\n// 8. If IRDY# is HIGH and STOP# is LOW, then STOP# remains stable in the next cycle.\n(IRDY# == 1'b1) && (STOP# == 1'b0) |-> ##1 $stable(STOP#)\n\n// 9. If IRDY# is HIGH and STOP# is LOW, then DEVSEL# remains stable in the next cycle.\n(IRDY# == 1'b1) && (STOP# == 1'b0) |-> ##1 $stable(DEVSEL#)\n\n// 10. If IRDY# is HIGH and TRDY# is LOW, then STOP# remains stable in the next cycle.\n(IRDY# == 1'b1) && (TRDY# == 1'b0) |-> ##1 $stable(STOP#)\n\n// 11. If FRAME# is LOW and IRDY# is LOW and TRDY# is HIGH, then IRDY# remains stable in the next cycle.\n(FRAME# == 1'b0) && (IRDY# == 1'b0) && (TRDY# == 1'b1) |-> ##1 $stable(IRDY#)\n\n// 12. If IRDY# is LOW and STOP# is HIGH and TRDY# is HIGH, then FRAME# remains stable in the next cycle.\n(IRDY# == 1'b0) && (STOP# == 1'b1) && (TRDY# == 1'b1) |-> ##1 $stable(FRAME#)\n\n// 13. If IRDY# is LOW and STOP# is HIGH and TRDY# is HIGH, then IRDY# remains stable in the next cycle.\n(IRDY# == 1'b0) && (STOP# == 1'b1) && (TRDY# == 1'b1) |-> ##1 $stable(IRDY#)\n\n// 14. If FRAME# is LOW and STOP# is LOW and TRDY# is HIGH, then TRDY# remains stable in the next cycle.\n(FRAME# == 1'b0) && (STOP# == 1'b0) && (TRDY# == 1'b1) |-> ##1 $stable(TRDY#)\n\n// 15. If FRAME# is LOW and STOP# is LOW and TRDY# is HIGH, then DEVSEL# remains stable in the next cycle.\n(FRAME# == 1'b0) && (STOP# == 1'b0) && (TRDY# == 1'b1) |-> ##1 $stable(DEVSEL#)\n\n\n// Manually-developed SVA properties:\n// 1. If FRAME# changes from LOW to HIGH, then IRDY# is LOW.\n$rose(FRAME#) |-> (IRDY# == 1'b0)\n\n// 2. If IRDY# is LOW and STOP# is HIGH and TRDY# is HIGH, then IRDY# remains stable in the next cycle.\n(IRDY# == 1'b0) && (STOP# == 1'b1) && (TRDY# == 1'b1) |-> ##1 $stable(IRDY#)\n\n// 3. If IRDY# is LOW and STOP# is HIGH and TRDY# is HIGH, then FRAME# remains stable in the next cycle.\n(IRDY# == 1'b0) && (STOP# == 1'b1) && (TRDY# == 1'b1) |-> ##1 $stable(FRAME#)\n\n// 4. If FRAME# is HIGH and IRDY# is LOW and TRDY# is LOW, then IRDY# is HIGH in the next cycle.\n(FRAME# == 1'b1) && (IRDY# == 1'b0) && (TRDY# == 1'b0) |-> ##1 (IRDY# == 1'b1)\n\n// 5. If FRAME# is HIGH and IRDY# is LOW and STOP# is LOW, then IRDY# is HIGH in the next cycle.\n(FRAME# == 1'b1) && (IRDY# == 1'b0) && (STOP# == 1'b0) |-> ##1 (IRDY# == 1'b1)\n\n// 6. If FRAME# is LOW and STOP# is LOW, then STOP# remains stable in the next cycle.\n(FRAME# == 1'b0) && (STOP# == 1'b0) |-> ##1 $stable(STOP#)\n\n// 7. If FRAME# is HIGH and STOP# is LOW, then STOP# is HIGH in the next cycle.\n(FRAME# == 1'b1) && (STOP# == 1'b0) |-> ##1 (STOP# == 1'b1)\n\n// 8. If IRDY# is HIGH and TRDY# is LOW, then TRDY# remains stable in the next cycle.\n(IRDY# == 1'b1) && (TRDY# == 1'b0) |-> ##1 $stable(TRDY#)\n\n// 9. If IRDY# is HIGH and TRDY# is LOW, then STOP# remains stable in the next cycle.\n(IRDY# == 1'b1) && (TRDY# == 1'b0) |-> ##1 $stable(STOP#)\n\n// 10. If IRDY# is HIGH and TRDY# is LOW, then DEVSEL# remains stable in the next cycle.\n(IRDY# == 1'b1) && (TRDY# == 1'b0) |-> ##1 $stable(DEVSEL#)\n\n// 11. If IRDY# is HIGH and STOP# is LOW, then TRDY# remains stable in the next cycle.\n(IRDY# == 1'b1) && (STOP# == 1'b0) |-> ##1 $stable(TRDY#)\n\n// 12. If IRDY# is HIGH and STOP# is LOW, then STOP# remains stable in the next cycle.\n(IRDY# == 1'b1) && (STOP# == 1'b0) |-> ##1 $stable(STOP#)\n\n// 13. If IRDY# is HIGH and STOP# is LOW, then DEVSEL# remains stable in the next cycle.\n(IRDY# == 1'b1) && (STOP# == 1'b0) |-> ##1 $stable(DEVSEL#)\n\n// 14. If STOP# is LOW, then FRAME# is HIGH or IRDY# is HIGH in the next cycle.\n(STOP# == 1'b0) |-> ##1 (FRAME# == 1'b1) || (IRDY# == 1'b1)\n\n// 15. If FRAME# is HIGH and IRDY# is LOW and TRDY# is LOW, then TRDY# is HIGH in the next cycle.\n(FRAME# == 1'b1) && (IRDY# == 1'b0) && (TRDY# == 1'b0) |-> ##1 (TRDY# == 1'b1)\n\n// 16. If FRAME# is HIGH and IRDY# is LOW and TRDY# is LOW, then STOP# is HIGH in the next cycle.\n(FRAME# == 1'b1) && (IRDY# == 1'b0) && (TRDY# == 1'b0) |-> ##1 (STOP# == 1'b1)\n\n// 17. If FRAME# is HIGH and IRDY# is LOW and TRDY# is LOW, then DEVSEL# is HIGH in the next cycle.\n(FRAME# == 1'b1) && (IRDY# == 1'b0) && (TRDY# == 1'b0) |-> ##1 (DEVSEL# == 1'b1)\n\n// 18. If FRAME# is HIGH and IRDY# is LOW and STOP# is LOW, then TRDY# is HIGH in the next cycle.\n(FRAME# == 1'b1) && (IRDY# == 1'b0) && (STOP# == 1'b0) |-> ##1 (TRDY# == 1'b1)\n\n// 19. If FRAME# is HIGH and IRDY# is LOW and STOP# is LOW, then STOP# is HIGH in the next cycle.\n(FRAME# == 1'b1) && (IRDY# == 1'b0) && (STOP# == 1'b0) |-> ##1 (STOP# == 1'b1)\n\n// 20. If FRAME# is HIGH and IRDY# is LOW and STOP# is LOW, then DEVSEL# is HIGH in the next cycle.\n(FRAME# == 1'b1) && (IRDY# == 1'b0) && (STOP# == 1'b0) |-> ##1 (DEVSEL# == 1'b1)\n\n"}]}]}}
