Protocol: Q-Channel handshake
Extracted Textual Description:
Q-Channel handshake: signal ownership and general rules
- Ownership: Controller drives QREQn. Device drives QACCEPTn and QDENY.
- Acknowledgment discipline: On any single handshake step, only one of the acknowledgment signals (QACCEPTn or QDENY) changes.
- Handshake is independent of QACTIVE (activity indication does not constrain handshake).
- Signal polarity/quiescent: All three handshake signals are LOW in the quiescent interface condition.
- All signals are assumed asynchronous; QREQn, QACCEPTn, and QDENY must be driven by registers.

Per-signal transition rules
- QREQn (controller)
  - HIGH → LOW only when QACCEPTn = HIGH and QDENY = LOW.
  - LOW → HIGH only when either:
    - QACCEPTn = LOW and QDENY = LOW, or
    - QACCEPTn = HIGH and QDENY = HIGH.

- QACCEPTn (device)
  - HIGH → LOW only when QREQn = LOW and QDENY = LOW.
  - LOW → HIGH only when QREQn = HIGH and QDENY = LOW.

- QDENY (device)
  - HIGH → LOW only when QREQn = HIGH and QACCEPTn = HIGH.
  - LOW → HIGH only when QREQn = LOW and QACCEPTn = HIGH.

Interface states (for reference to the rules)
- Q_RUN: QREQn=1, QACCEPTn=1, QDENY=0. Device operational; controller guarantees clock/power.
- Q_REQUEST: QREQn=0, QACCEPTn=1, QDENY=0. Requesting quiescence; controller guarantees clock/power.
- Q_STOPPED: QREQn=0, QACCEPTn=0, QDENY=0. Device quiescent; controller does not guarantee clock/power.
- Q_EXIT: QREQn=1, QACCEPTn=0, QDENY=0. Exit quiescence; clock/power guaranteed after an implementation-dependent delay, then maintained.
- Q_DENIED: QREQn=0, QACCEPTn=1, QDENY=1. Device denied quiescence; controller must keep clock/power and deassert QREQn.
- Q_CONTINUE: QREQn=1, QACCEPTn=1, QDENY=1. Post-denial; device operational.
- Illegal: QDENY=1 with QACCEPTn=0.

================================================================================

Protocol: Q-Channel reset
Extracted Textual Description:
Q-Channel device reset mechanism (standard, non-parity)

General rule to assert reset
- The controller must only assert device RESETn LOW when the interface is in Q_STOPPED (QREQn=0, QACCEPTn=0, QDENY=0), or when the controller and device are reset simultaneously. Rationale: supports “all signals LOW” isolation at power boundaries.

Behavior while RESETn is asserted (RESETn=0)
- Device must drive QACCEPTn=0.
- Device must drive QDENY=0.
- QREQn is driven by the controller; no additional protocol requirements beyond the assertion constraint above.

Releasing reset (RESETn transitions HIGH): allowed controller options and resulting states
1) Release with QREQn LOW
   - Required signal levels at deassertion: RESETn=1, QREQn=0, QACCEPTn=0, QDENY=0.
   - Resulting state: Q_STOPPED (device is not operational; controller does not guarantee clock/power managed by the interface).
   - Subsequent exit: When the controller later sets QREQn=1, the interface enters Q_EXIT and the device will raise QACCEPTn=1 to reach Q_RUN.

2) Release with QREQn HIGH (only if the controller can meet resource guarantees)
   - Required signal levels at deassertion: RESETn=1, QREQn=1, QACCEPTn=0, QDENY=0.
   - Resulting state: Q_EXIT. Any clock or power managed by the interface must be guaranteed by the controller after an implementation‑dependent delay.
   - Completion: The device drives QACCEPTn=1 to move to Q_RUN.

Post-reset defaults
- After reset deassertion, QACCEPTn remains 0 and QDENY remains 0 until the device completes the next handshake transition dictated by QREQn.
- Denial is not expressed during reset; QDENY must be 0 at and immediately after reset deassertion until a valid denial handshake occurs later.

Summary of reset-driven signal requirements
- On RESETn=0: QACCEPTn=0, QDENY=0 (required).
- To assert RESETn: do so only in Q_STOPPED (QREQn=0, QACCEPTn=0, QDENY=0) or with simultaneous controller/device reset.
- On RESETn↑ with QREQn=0: remain in Q_STOPPED.
- On RESETn↑ with QREQn=1: enter Q_EXIT; controller must guarantee clock/power; device will then set QACCEPTn=1 to reach Q_RUN.

================================================================================

Protocol: P-Channel handshake
Extracted Textual Description:
Target: P-Channel handshake rules (signals: PREQ, PACCEPT, PDENY, PSTATE). No reset behavior included.

General handshake invariants
- PREQ is the controller’s request to transition to the power state encoded on PSTATE.
- PACCEPT (device → controller) accepts the requested transition; PDENY (device → controller) denies it.
- Only one of PACCEPT or PDENY changes per handshake transition.
- Handshake is independent of PACTIVE.
- Controller must only present supported PSTATE values and supported transitions.

Per-signal rules

PREQ (controller → device)
- May transition LOW→HIGH only when PACCEPT=0 and PDENY=0.
- May transition HIGH→LOW only when either:
  • PACCEPT=1 and PDENY=0 (accepted path), or
  • PACCEPT=0 and PDENY=1 (denied path).
- Requirement on PSTATE timing:
  • PSTATE must be stable when the device detects PREQ HIGH (rising-side sampling).
  • In the denial path, PSTATE must be stable at the current-state value when the device later detects PREQ LOW.

PACCEPT (device → controller)
- May transition LOW→HIGH only when PREQ=1 and PDENY=0.
- Must remain HIGH until the device samples PREQ=0, then:
- May transition HIGH→LOW only when PREQ=0 and PDENY=0.

PDENY (device → controller)
- May transition LOW→HIGH only when PREQ=1 and PACCEPT=0.
- Must remain HIGH until the device samples PREQ=0, then:
- May transition HIGH→LOW only when PREQ=0 and PACCEPT=0.

PSTATE (controller → device)
- Encodes the target power state for the request.
- Allowed to change only when either:
  • PREQ=0 and PACCEPT=0 and PDENY=0 (stable/idle), or
  • PREQ=1 and PDENY=1 and PACCEPT=0 (during denial handling so the controller can restore/set the current-state value).
- Must be stable when PREQ HIGH is observed by the device (so the device captures the intended target state).

Sequence summaries

Accepted transition
1) Controller places target PSTATE; asserts PREQ=1 (PSTATE stable at this time).
2) Device asserts PACCEPT=1 (PDENY stays 0).
3) Controller deasserts PREQ=0.
4) Device deasserts PACCEPT=0. Handshake complete.

Denied transition
1) Controller places target PSTATE; asserts PREQ=1 (PSTATE stable at this time).
2) Device asserts PDENY=1 (PACCEPT stays 0).
3) Controller sets PSTATE to the current-state value while PREQ=1, then deasserts PREQ=0.
4) Device deasserts PDENY=0. Handshake complete.

================================================================================

Protocol: P-Channel reset
Extracted Textual Description:
P-Channel device reset mechanism – signal interaction rules

Overall rule to assert reset
- A controller must only assert device reset when the interface is in P_STABLE, or when the controller and the device are reset simultaneously.

While RESETn is asserted (RESETn = 0) — P_RESET state
- PACCEPT = 0.
- PDENY = 0.
- PREQ is don’t care (ignored by the device).
- PSTATE is driven by the controller and may be set to the desired post-reset state value (see deassertion rules below).

At RESETn deassertion (RESETn: 0 → 1) — initialization behavior
- PSTATE requirement:
  - PSTATE must be stable when reset deassertion is detected at the device.
  - The device must capture PSTATE within an implementation-defined initialization period tinit (in device clock cycles). The controller must ensure an appropriate clock is running during tinit so the capture can occur.
  - If the sampled PSTATE differs from the device default, the device can internally transition to that state and should delay responding to subsequent P-Channel requests until that internal transition is complete.

- PREQ options around reset deassertion (device must accept the first request):
  1) PREQ = 0 at deassertion, controller waits until tinit expires, then issues the first request. (Required behavior for unused interfaces.)
  2) PREQ = 1 before deassertion; the controller waits until the first P-Channel transition completes before issuing a further request. The device is guaranteed ready for another request when this first transition completes (even if completion occurs within tinit).
  3) PREQ = 0 at deassertion; during tinit the controller keeps PSTATE unchanged and asserts PREQ = 1. Whether the device treats this as a second transition is implementation-defined; the controller waits for completion. In all cases, the device must accept the first request issued at reset exit or during tinit.

- PACCEPT/PDENY behavior at/after deassertion:
  - Both remain 0 until the device evaluates PREQ.
  - For the first request at reset exit or during tinit, the device must accept; therefore PACCEPT will be driven 1 (when the device accepts) and PDENY must not be asserted for that first request.
  - Normal handshake semantics then apply: after the controller observes PACCEPT = 1 it must drive PREQ = 0; the device then returns PACCEPT = 0 to complete the transition.

Post-reset steady state (after tinit and any first transition)
- Normal P-Channel rules apply:
  - PREQ may be asserted to request further transitions; PDENY may be used to deny requests (except for the mandatory acceptance of the first post-reset request as stated above).

Special cases and tie-offs
- Unused interface: tie PREQ = 0; tie PSTATE to a functional state the device supports directly from reset. The device must enter that state at reset deassertion.
- State definition: Device documentation must specify tinit and which PSTATE encodings are supported at reset deassertion for initialization.

================================================================================

Protocol: AXI channel handshake
Extracted Textual Description:
AXI channel master/slave handshake rules (VALID/READY/INFORMATION)

Transfer rule
- A transfer (beat) occurs only in a cycle where VALID = 1 and READY = 1. Sampling is on the rising edge of ACLK.
- Three legal sequences: VALID before READY, READY before VALID, or both high in the same cycle.

VALID (source side)
- Driven by the source of the channel (master for address/write data, slave for read data/response).
- May be asserted without waiting for READY. VALID must not be generated combinationally from the other side’s READY.
- VALID can be asserted only when the INFORMATION signals carry a valid item.
- Once asserted, VALID must remain high and the INFORMATION must remain stable until the transfer completes (i.e., until a cycle occurs with READY = 1).
- After the handshake, VALID can be deasserted or the next item can be presented.

READY (destination side)
- Driven by the destination of the channel (slave for address/write data, master for read data/response).
- READY may be held low to apply backpressure and may be asserted by default if the destination can always accept data.
- READY may wait for VALID, but must not cause the source to wait (i.e., it is permitted to depend on VALID; the reverse is not).
- READY must not be generated via a combinational path from the source inputs to the destination outputs.

INFORMATION (payload/control on the channel)
- Must be valid and held stable whenever VALID = 1 and until the transfer occurs (VALID && READY).
- Can change in the cycle after a successful transfer or while VALID = 0.
- The destination must only capture/use INFORMATION in cycles where VALID && READY = 1.

Additional interface constraint
- There must be no combinatorial paths between input and output signals on either master or slave interfaces (prevents combinational READY↔VALID loops and ensures proper registration).

================================================================================

Protocol: AXI reset
Extracted Textual Description:
AXI reset requirements – rules for ARESETn and VALID

ARESETn (global reset)
- Active-LOW reset.
- Assertion can be asynchronous.
- Deassertion must be synchronous to ACLK: reset must go HIGH only in synchronization with a rising edge of ACLK.
- While ARESETn = 0 (in reset):
  - Master interfaces must drive ARVALID = 0, AWVALID = 0, WVALID = 0.
  - Slave interfaces must drive RVALID = 0, BVALID = 0.
  - All other signals may take any value.
- After ARESETn = 1 (out of reset):
  - A master may begin asserting ARVALID/AWVALID/WVALID only on a rising edge of ACLK that occurs after ARESETn is HIGH (earliest allowed is the first rising edge after reset release).

VALID family (ARVALID, AWVALID, WVALID, RVALID, BVALID)
- During reset (ARESETn = 0):
  - Masters: ARVALID = 0, AWVALID = 0, WVALID = 0.
  - Slaves: RVALID = 0, BVALID = 0.
- After reset release (ARESETn = 1):
  - Masters may assert ARVALID/AWVALID/WVALID only synchronously at a rising edge of ACLK occurring after reset deassertion.
- No combinatorial paths are permitted between interface inputs and outputs; VALID generation must therefore be registered/synchronous.

================================================================================

Protocol: AXI low-power handshake
Extracted Textual Description:
AXI low-power handshake rules (CSYSREQ, CSYSACK)

General
- Two-wire level handshake between the system clock controller (CSYSREQ) and the peripheral (CSYSACK).
- Normal clocked operation: CSYSREQ=1 and CSYSACK=1.
- Low-power state: CSYSREQ=0 and CSYSACK=0. (CACTIVE is 0 if the request was accepted.)
- The protocol requires the paired transitions: CSYSREQ low must be followed by CSYSACK low; CSYSREQ high must be followed by CSYSACK high. A new request must not start until the previous handshake has completed (both back high).

CSYSREQ (driven by system clock controller)
- Request entry to low-power: drive CSYSREQ=0 and hold it until the peripheral responds by driving CSYSACK=0.
- Request/confirm exit from low-power: drive CSYSREQ=1 and hold it until the peripheral responds by driving CSYSACK=1.
- If the peripheral initiated the exit by asserting CACTIVE, immediately enable the clock and then drive CSYSREQ=1 to complete the handshake.
- If a low-power entry was denied (peripheral kept CACTIVE=1 while asserting CSYSACK=0), the controller must still complete the handshake by re-asserting CSYSREQ=1 and waiting for CSYSACK=1 before issuing another request.

CSYSACK (driven by peripheral)
- Acknowledge entry request: after detecting CSYSREQ=0, drive CSYSACK=0.
  - Acceptance vs denial is indicated by CACTIVE at the time CSYSACK goes low:
    - CACTIVE=0 → request accepted (peripheral may first perform its power-down, then drop CSYSACK).
    - CACTIVE=1 → request denied (no power-down). Controller must finish the handshake by returning CSYSREQ high.
- Acknowledge exit request: after detecting CSYSREQ=1, drive CSYSACK=1. The peripheral may delay asserting CSYSACK until its power-up sequence completes.
- During peripheral-initiated exit, assert CACTIVE=1 first; after the controller drives CSYSREQ=1, assert CSYSACK=1 to finish the sequence.

Notes for multi-peripheral low-power domains
- A single CSYSREQ can fan out to all peripherals.
- Domain CSYSACK low occurs when all peripherals have driven CSYSACK low; domain CSYSACK high occurs when all have driven it high.

================================================================================

Protocol: WISHBONE data transfer
Extracted Textual Description:
Scope: WISHBONE Classic bus cycles; ERR_I/RTY_I are not used. ACK_I is the only terminator. All outputs are registered on the rising edge of CLK_I; inputs must be stable before the rising edge.

CYC_O (Cycle)
- Must be asserted for the entire duration of a SINGLE/BLOCK/RMW classic cycle.
- Must be asserted no later than the rising CLK edge that qualifies the assertion of STB_O.
- Must be negated no earlier than the rising CLK edge that qualifies the negation of STB_O.
- Recommendation: do not hold CYC_O asserted indefinitely.
- If the master never inserts wait states, CYC_O may be the same signal as STB_O (both ports still present).

STB_O (Strobe)
- Assert to start a transfer phase when ready.
- Keep asserted until the master samples ACK_I = 1 at a rising CLK edge.
- Negate on the clock edge following the sampled assertion of ACK_I.
- May be negated between phases to insert master wait states; re-assert to continue the next phase while CYC_O stays high.
- Must qualify (i.e., be high whenever valid values are driven on) ADR_O, DAT_O, WE_O, and SEL_O.

ACK_I (Acknowledge)
- Indicates normal termination of the current transfer phase.
- Master samples at every rising CLK edge; when sampled high, the phase completes:
  - master latches DAT_I (READ) or knows the SLAVE has accepted DAT_O (WRITE),
  - master negates STB_O next cycle; if this was the last phase, it also negates CYC_O.
- Slave generates ACK_O in response to CYC_I AND STB_I; may be asserted asynchronously and is asserted/negated in response to STB_I.
- Master must operate correctly even if a slave holds ACK_I continuously asserted.

ADR_O (Address)
- Must be valid and stable whenever STB_O is asserted; may change for the next phase after the current phase is completed (i.e., after ACK_I is sampled).
- For BLOCK cycles, a new ADR_O may be presented for the next phase while CYC_O remains asserted.

DAT_I (Read data, input to master)
- Considered valid only with ACK_I; master latches DAT_I on the rising CLK edge where ACK_I is sampled high.
- May be undefined in cycles or phases until ACK_I is asserted.

DAT_O (Write data, output from master)
- Must be valid and stable whenever STB_O is asserted during WRITE phases; slave latches on the rising CLK edge where it asserts ACK_O (seen as ACK_I by the master).
- May change for the next phase after the current phase completes.

WE_O (Write enable)
- 0 = READ, 1 = WRITE.
- Must be valid and stable whenever STB_O is asserted and remain stable for the phase until ACK_I is sampled.

SEL_O (Byte enables)
- Indicates active byte lanes for the transfer.
- Must be valid and stable whenever STB_O is asserted and remain stable for the phase until ACK_I is sampled.

Additional handshake behavior
- Slave-inserted wait states: the slave throttles by withholding ACK_O; master keeps STB_O asserted until ACK_I is sampled.
- Master-inserted wait states: master throttles by negating STB_O between phases while keeping CYC_O asserted (BLOCK/RMW cycles).

================================================================================

Protocol: WISHBONE reset
Extracted Textual Description:
WISHBONE Classic reset operation – rules for RST_I, STB_O, CYC_O

RST_I (Reset input)
- Minimum assertion: MUST be asserted for at least one complete clock cycle (Rule 3.05).
- Duration: MAY be asserted for more than one cycle and MAY be asserted indefinitely (Permission 3.00).
- Reaction timing: All interfaces MUST initialize at the rising CLK_I edge following the assertion of RST_I, and MUST remain initialized until the rising CLK_I edge that follows the negation of RST_I (Rule 3.00).
- Responsiveness: All interfaces MUST be capable of reacting to RST_I at any time (Rule 3.10).
- State machines/counters: All self-starting state machines and counters MUST initialize at the rising CLK_I edge following assertion of RST_I and remain initialized until the rising edge after negation of RST_I (Rule 3.15).

STB_O (Master strobe output)
- During reset: MUST be negated at the rising CLK_I edge following assertion of RST_I and MUST stay negated until the rising CLK_I edge that follows the negation of RST_I (Rule 3.20).
- After reset release: MAY be asserted beginning at the first rising CLK_I edge after RST_I is negated (Observation 3.05 / Fig. 3-1 note).

CYC_O (Master cycle output)
- During reset: MUST be negated at the rising CLK_I edge following assertion of RST_I and MUST stay negated until the rising CLK_I edge that follows the negation of RST_I (Rule 3.20).
- After reset release: MAY be asserted beginning at the first rising CLK_I edge after RST_I is negated (Observation 3.05 / Fig. 3-1 note).

================================================================================

Protocol: APB transfers
Extracted Textual Description:
APB write/read transfer rules for: PADDR, PSEL, PENABLE, PWRITE, PWDATA, PREADY, PRDATA

General
- All APB signals are sampled on the rising edge of PCLK.
- A transfer has two phases: SETUP (one cycle) then ACCESS (one or more cycles).
- A transfer completes in the cycle where PSEL=1, PENABLE=1, and PREADY=1.
- While a transfer is being extended (PENABLE=1 and PREADY=0), the following must remain unchanged: PADDR, PWRITE, PSEL, PENABLE, PWDATA (writes), and any other control/user signals.

PADDR (Requester → Completer)
- Byte address; may be unaligned but behavior is UNPREDICTABLE if unaligned.
- Must be valid when PSEL=1 (SETUP).
- Must not change between SETUP and ACCESS, nor in any ACCESS cycle.
- Remains stable while PREADY=0.
- Sampled at completion of the transfer.

PSEL (Requester → Completer)
- 1 selects the target Completer and starts the SETUP phase; 0 indicates IDLE.
- Must always be driven to a valid 0/1 level.
- Assert for SETUP; keep asserted through ACCESS.
- Deassert after completion unless another transfer to the same Completer follows (in which case the interface can go directly to the next SETUP).

PENABLE (Requester → Completer)
- 0 in SETUP; 1 in ACCESS (asserted the cycle after PSEL is asserted).
- Must not change during ACCESS.
- Deasserted at the end of the transfer.

PWRITE (Requester → Completer)
- 1 = write transfer; 0 = read transfer.
- Must be valid in SETUP when PSEL=1.
- Must not change from SETUP into ACCESS or while PREADY=0.

PWDATA (Requester → Completer; write only)
- Must be valid in SETUP when PSEL=1 and PWRITE=1 (active byte lanes only).
- Must remain stable from SETUP through all ACCESS cycles until completion.
- Not used in read transfers.

PREADY (Completer → Requester)
- Indicates completion/extension during ACCESS.
- If PENABLE=1 and PREADY=1, the transfer completes in that cycle.
- If PENABLE=1 and PREADY=0, the transfer is extended; all request/control signals listed above must remain unchanged.
- Can take any value when PENABLE=0 (allows fixed two-cycle peripherals to tie PREADY high).
- Must be valid when PSEL=1 and PENABLE=1.

PRDATA (Completer → Requester; read only)
- Must be valid in the completion cycle of a read: when PSEL=1, PENABLE=1, PREADY=1, and PWRITE=0.
- Provided by the Completer before the end of the read transfer; sampled on completion.

================================================================================

Protocol: PCI transaction termination
Extracted Textual Description:
PCI transaction termination – signal interaction rules

General
- A data phase completes on any rising clock edge where IRDY# is asserted and either TRDY# or STOP# is asserted. If TRDY# is asserted, data transfers; if only STOP# is asserted, no data transfers in that phase.
- The bus returns to Idle when both FRAME# and IRDY# are deasserted.

FRAME#
- Master asserts FRAME# to start a transaction. To terminate, the master deasserts FRAME# while asserting IRDY#; this makes the current phase the final one.
- FRAME# cannot be deasserted unless IRDY# is asserted. Once deasserted, it cannot be reasserted in the same transaction.
- Once the master has asserted IRDY#, it cannot change FRAME# until the current data phase completes.
- If the target asserts STOP#, the master must deassert FRAME# as soon as it can assert IRDY#.
- Master‑Abort: if no target asserts DEVSEL# by the allowed decode window (up to clock 5 from the first assertion of FRAME#), the master terminates with Master‑Abort by deasserting FRAME# and then IRDY#. Earliest termination is five clocks after FRAME# was first asserted.
- Timeout termination: when the master’s Latency Timer expires and GNT# is deasserted, the master must deassert FRAME# and end the transaction at the next legal phase boundary (for Memory Write and Invalidate, at a cacheline boundary).

IRDY#
- Asserted by the master when ready for the current data phase.
- A data phase completes on a clock where IRDY# and TRDY# are both asserted or IRDY# and STOP# are both asserted.
- Once asserted, IRDY# cannot change until the current data phase completes.
- In the last phase, the master asserts IRDY# and deasserts FRAME#; IRDY# must remain asserted until the last transfer occurs, then be deasserted on the next clock.

TRDY#
- Asserted by the target when it can complete the current data phase; cannot be driven until DEVSEL# is asserted.
- Once the target has asserted TRDY# (or STOP#), it cannot change TRDY#, STOP#, or DEVSEL# until the current data phase completes.
- With IRDY# asserted, TRDY# causes a data transfer. With STOP# asserted at the same time, it is a Disconnect with Data (only the current phase completes).
- TRDY# must be deasserted the clock following completion of the last data phase and tri‑stated on the next clock.

STOP#
- Asserted by the target to request termination.
- Retry (busy, no data): on the initial data phase only, the target asserts STOP# and does not assert TRDY# (STOP# cannot be asserted during the address‑to‑data turn‑around of a read). Master must repeat the request unconditionally.
- Disconnect With Data: target asserts STOP# and TRDY# together; only the current data phase completes, then the master must end the transaction.
- Disconnect Without Data: on a subsequent phase (i.e., data was transferred in the previous phase), the target deasserts TRDY# and asserts STOP#; the current phase completes without transferring data.
- Once asserted, STOP# must remain asserted until FRAME# is deasserted, after which STOP# is deasserted on the next clock.

DEVSEL#
- Asserted by the target when it positively decodes the address; asserted in fast/medium/slow windows (1/2/3 clocks). If no device asserts DEVSEL# by the allowed window (up to clock 5), the master must terminate with Master‑Abort.
- During a data phase, once the target has asserted TRDY# or STOP#, DEVSEL# cannot change until that data phase completes.
- Target‑Abort: an abnormal termination signaled by deasserting DEVSEL# and asserting STOP# in the same clock.
- DEVSEL#, TRDY#, and STOP# must all be deasserted the clock after the last data phase completes and tri‑stated on the following clock.

================================================================================

