[
    {
        "protocol": "Q-Channel handshake",
        "candidates": "../../test_cases/Q-Channel/handshake/sat_filtered_NL.json",
        "textual_description": "Q-Channel handshake: signal ownership and general rules\n- Ownership: Controller drives QREQn. Device drives QACCEPTn and QDENY.\n- Acknowledgment discipline: On any single handshake step, only one of the acknowledgment signals (QACCEPTn or QDENY) changes.\n- Handshake is independent of QACTIVE (activity indication does not constrain handshake).\n- Signal polarity/quiescent: All three handshake signals are LOW in the quiescent interface condition.\n- All signals are assumed asynchronous; QREQn, QACCEPTn, and QDENY must be driven by registers.\n\nPer-signal transition rules\n- QREQn (controller)\n  - HIGH \u2192 LOW only when QACCEPTn = HIGH and QDENY = LOW.\n  - LOW \u2192 HIGH only when either:\n    - QACCEPTn = LOW and QDENY = LOW, or\n    - QACCEPTn = HIGH and QDENY = HIGH.\n\n- QACCEPTn (device)\n  - HIGH \u2192 LOW only when QREQn = LOW and QDENY = LOW.\n  - LOW \u2192 HIGH only when QREQn = HIGH and QDENY = LOW.\n\n- QDENY (device)\n  - HIGH \u2192 LOW only when QREQn = HIGH and QACCEPTn = HIGH.\n  - LOW \u2192 HIGH only when QREQn = LOW and QACCEPTn = HIGH.\n\nInterface states (for reference to the rules)\n- Q_RUN: QREQn=1, QACCEPTn=1, QDENY=0. Device operational; controller guarantees clock/power.\n- Q_REQUEST: QREQn=0, QACCEPTn=1, QDENY=0. Requesting quiescence; controller guarantees clock/power.\n- Q_STOPPED: QREQn=0, QACCEPTn=0, QDENY=0. Device quiescent; controller does not guarantee clock/power.\n- Q_EXIT: QREQn=1, QACCEPTn=0, QDENY=0. Exit quiescence; clock/power guaranteed after an implementation-dependent delay, then maintained.\n- Q_DENIED: QREQn=0, QACCEPTn=1, QDENY=1. Device denied quiescence; controller must keep clock/power and deassert QREQn.\n- Q_CONTINUE: QREQn=1, QACCEPTn=1, QDENY=1. Post-denial; device operational.\n- Illegal: QDENY=1 with QACCEPTn=0."
    },
    {
        "protocol": "Q-Channel reset",
        "candidates": "../../test_cases/Q-Channel/reset/sat_filtered_NL.json",
        "textual_description": "Q-Channel device reset mechanism (standard, non-parity)\n\nGeneral rule to assert reset\n- The controller must only assert device RESETn LOW when the interface is in Q_STOPPED (QREQn=0, QACCEPTn=0, QDENY=0), or when the controller and device are reset simultaneously. Rationale: supports \u201call signals LOW\u201d isolation at power boundaries.\n\nBehavior while RESETn is asserted (RESETn=0)\n- Device must drive QACCEPTn=0.\n- Device must drive QDENY=0.\n- QREQn is driven by the controller; no additional protocol requirements beyond the assertion constraint above.\n\nReleasing reset (RESETn transitions HIGH): allowed controller options and resulting states\n1) Release with QREQn LOW\n   - Required signal levels at deassertion: RESETn=1, QREQn=0, QACCEPTn=0, QDENY=0.\n   - Resulting state: Q_STOPPED (device is not operational; controller does not guarantee clock/power managed by the interface).\n   - Subsequent exit: When the controller later sets QREQn=1, the interface enters Q_EXIT and the device will raise QACCEPTn=1 to reach Q_RUN.\n\n2) Release with QREQn HIGH (only if the controller can meet resource guarantees)\n   - Required signal levels at deassertion: RESETn=1, QREQn=1, QACCEPTn=0, QDENY=0.\n   - Resulting state: Q_EXIT. Any clock or power managed by the interface must be guaranteed by the controller after an implementation\u2011dependent delay.\n   - Completion: The device drives QACCEPTn=1 to move to Q_RUN.\n\nPost-reset defaults\n- After reset deassertion, QACCEPTn remains 0 and QDENY remains 0 until the device completes the next handshake transition dictated by QREQn.\n- Denial is not expressed during reset; QDENY must be 0 at and immediately after reset deassertion until a valid denial handshake occurs later.\n\nSummary of reset-driven signal requirements\n- On RESETn=0: QACCEPTn=0, QDENY=0 (required).\n- To assert RESETn: do so only in Q_STOPPED (QREQn=0, QACCEPTn=0, QDENY=0) or with simultaneous controller/device reset.\n- On RESETn\u2191 with QREQn=0: remain in Q_STOPPED.\n- On RESETn\u2191 with QREQn=1: enter Q_EXIT; controller must guarantee clock/power; device will then set QACCEPTn=1 to reach Q_RUN."
    },
    {
        "protocol": "P-Channel handshake",
        "candidates": "../../test_cases/P-Channel/handshake/sat_filtered_NL.json",
        "textual_description": "Target: P-Channel handshake rules (signals: PREQ, PACCEPT, PDENY, PSTATE). No reset behavior included.\n\nGeneral handshake invariants\n- PREQ is the controller\u2019s request to transition to the power state encoded on PSTATE.\n- PACCEPT (device \u2192 controller) accepts the requested transition; PDENY (device \u2192 controller) denies it.\n- Only one of PACCEPT or PDENY changes per handshake transition.\n- Handshake is independent of PACTIVE.\n- Controller must only present supported PSTATE values and supported transitions.\n\nPer-signal rules\n\nPREQ (controller \u2192 device)\n- May transition LOW\u2192HIGH only when PACCEPT=0 and PDENY=0.\n- May transition HIGH\u2192LOW only when either:\n  \u2022 PACCEPT=1 and PDENY=0 (accepted path), or\n  \u2022 PACCEPT=0 and PDENY=1 (denied path).\n- Requirement on PSTATE timing:\n  \u2022 PSTATE must be stable when the device detects PREQ HIGH (rising-side sampling).\n  \u2022 In the denial path, PSTATE must be stable at the current-state value when the device later detects PREQ LOW.\n\nPACCEPT (device \u2192 controller)\n- May transition LOW\u2192HIGH only when PREQ=1 and PDENY=0.\n- Must remain HIGH until the device samples PREQ=0, then:\n- May transition HIGH\u2192LOW only when PREQ=0 and PDENY=0.\n\nPDENY (device \u2192 controller)\n- May transition LOW\u2192HIGH only when PREQ=1 and PACCEPT=0.\n- Must remain HIGH until the device samples PREQ=0, then:\n- May transition HIGH\u2192LOW only when PREQ=0 and PACCEPT=0.\n\nPSTATE (controller \u2192 device)\n- Encodes the target power state for the request.\n- Allowed to change only when either:\n  \u2022 PREQ=0 and PACCEPT=0 and PDENY=0 (stable/idle), or\n  \u2022 PREQ=1 and PDENY=1 and PACCEPT=0 (during denial handling so the controller can restore/set the current-state value).\n- Must be stable when PREQ HIGH is observed by the device (so the device captures the intended target state).\n\nSequence summaries\n\nAccepted transition\n1) Controller places target PSTATE; asserts PREQ=1 (PSTATE stable at this time).\n2) Device asserts PACCEPT=1 (PDENY stays 0).\n3) Controller deasserts PREQ=0.\n4) Device deasserts PACCEPT=0. Handshake complete.\n\nDenied transition\n1) Controller places target PSTATE; asserts PREQ=1 (PSTATE stable at this time).\n2) Device asserts PDENY=1 (PACCEPT stays 0).\n3) Controller sets PSTATE to the current-state value while PREQ=1, then deasserts PREQ=0.\n4) Device deasserts PDENY=0. Handshake complete."
    },
    {
        "protocol": "P-Channel reset",
        "candidates": "../../test_cases/P-Channel/reset/sat_filtered_NL.json",
        "textual_description": "P-Channel device reset mechanism \u2013 signal interaction rules\n\nOverall rule to assert reset\n- A controller must only assert device reset when the interface is in P_STABLE, or when the controller and the device are reset simultaneously.\n\nWhile RESETn is asserted (RESETn = 0) \u2014 P_RESET state\n- PACCEPT = 0.\n- PDENY = 0.\n- PREQ is don\u2019t care (ignored by the device).\n- PSTATE is driven by the controller and may be set to the desired post-reset state value (see deassertion rules below).\n\nAt RESETn deassertion (RESETn: 0 \u2192 1) \u2014 initialization behavior\n- PSTATE requirement:\n  - PSTATE must be stable when reset deassertion is detected at the device.\n  - The device must capture PSTATE within an implementation-defined initialization period tinit (in device clock cycles). The controller must ensure an appropriate clock is running during tinit so the capture can occur.\n  - If the sampled PSTATE differs from the device default, the device can internally transition to that state and should delay responding to subsequent P-Channel requests until that internal transition is complete.\n\n- PREQ options around reset deassertion (device must accept the first request):\n  1) PREQ = 0 at deassertion, controller waits until tinit expires, then issues the first request. (Required behavior for unused interfaces.)\n  2) PREQ = 1 before deassertion; the controller waits until the first P-Channel transition completes before issuing a further request. The device is guaranteed ready for another request when this first transition completes (even if completion occurs within tinit).\n  3) PREQ = 0 at deassertion; during tinit the controller keeps PSTATE unchanged and asserts PREQ = 1. Whether the device treats this as a second transition is implementation-defined; the controller waits for completion. In all cases, the device must accept the first request issued at reset exit or during tinit.\n\n- PACCEPT/PDENY behavior at/after deassertion:\n  - Both remain 0 until the device evaluates PREQ.\n  - For the first request at reset exit or during tinit, the device must accept; therefore PACCEPT will be driven 1 (when the device accepts) and PDENY must not be asserted for that first request.\n  - Normal handshake semantics then apply: after the controller observes PACCEPT = 1 it must drive PREQ = 0; the device then returns PACCEPT = 0 to complete the transition.\n\nPost-reset steady state (after tinit and any first transition)\n- Normal P-Channel rules apply:\n  - PREQ may be asserted to request further transitions; PDENY may be used to deny requests (except for the mandatory acceptance of the first post-reset request as stated above).\n\nSpecial cases and tie-offs\n- Unused interface: tie PREQ = 0; tie PSTATE to a functional state the device supports directly from reset. The device must enter that state at reset deassertion.\n- State definition: Device documentation must specify tinit and which PSTATE encodings are supported at reset deassertion for initialization."
    },
    {
        "protocol": "AXI channel handshake",
        "candidates": "../../test_cases/AXI/channel_handshake/sat_filtered_NL.json",
        "textual_description": "AXI channel master/slave handshake rules (VALID/READY/INFORMATION)\n\nTransfer rule\n- A transfer (beat) occurs only in a cycle where VALID = 1 and READY = 1. Sampling is on the rising edge of ACLK.\n- Three legal sequences: VALID before READY, READY before VALID, or both high in the same cycle.\n\nVALID (source side)\n- Driven by the source of the channel (master for address/write data, slave for read data/response).\n- May be asserted without waiting for READY. VALID must not be generated combinationally from the other side\u2019s READY.\n- VALID can be asserted only when the INFORMATION signals carry a valid item.\n- Once asserted, VALID must remain high and the INFORMATION must remain stable until the transfer completes (i.e., until a cycle occurs with READY = 1).\n- After the handshake, VALID can be deasserted or the next item can be presented.\n\nREADY (destination side)\n- Driven by the destination of the channel (slave for address/write data, master for read data/response).\n- READY may be held low to apply backpressure and may be asserted by default if the destination can always accept data.\n- READY may wait for VALID, but must not cause the source to wait (i.e., it is permitted to depend on VALID; the reverse is not).\n- READY must not be generated via a combinational path from the source inputs to the destination outputs.\n\nINFORMATION (payload/control on the channel)\n- Must be valid and held stable whenever VALID = 1 and until the transfer occurs (VALID && READY).\n- Can change in the cycle after a successful transfer or while VALID = 0.\n- The destination must only capture/use INFORMATION in cycles where VALID && READY = 1.\n\nAdditional interface constraint\n- There must be no combinatorial paths between input and output signals on either master or slave interfaces (prevents combinational READY\u2194VALID loops and ensures proper registration)."
    },
    {
        "protocol": "AXI reset",
        "candidates": "../../test_cases/AXI/reset/sat_filtered_NL.json",
        "textual_description": "AXI reset requirements \u2013 rules for ARESETn and VALID\n\nARESETn (global reset)\n- Active-LOW reset.\n- Assertion can be asynchronous.\n- Deassertion must be synchronous to ACLK: reset must go HIGH only in synchronization with a rising edge of ACLK.\n- While ARESETn = 0 (in reset):\n  - Master interfaces must drive ARVALID = 0, AWVALID = 0, WVALID = 0.\n  - Slave interfaces must drive RVALID = 0, BVALID = 0.\n  - All other signals may take any value.\n- After ARESETn = 1 (out of reset):\n  - A master may begin asserting ARVALID/AWVALID/WVALID only on a rising edge of ACLK that occurs after ARESETn is HIGH (earliest allowed is the first rising edge after reset release).\n\nVALID family (ARVALID, AWVALID, WVALID, RVALID, BVALID)\n- During reset (ARESETn = 0):\n  - Masters: ARVALID = 0, AWVALID = 0, WVALID = 0.\n  - Slaves: RVALID = 0, BVALID = 0.\n- After reset release (ARESETn = 1):\n  - Masters may assert ARVALID/AWVALID/WVALID only synchronously at a rising edge of ACLK occurring after reset deassertion.\n- No combinatorial paths are permitted between interface inputs and outputs; VALID generation must therefore be registered/synchronous."
    },
    {
        "protocol": "AXI low-power handshake",
        "candidates": "../../test_cases/AXI/low_power_handshake/sat_filtered_NL.json",
        "textual_description": "AXI low-power handshake rules (CSYSREQ, CSYSACK)\n\nGeneral\n- Two-wire level handshake between the system clock controller (CSYSREQ) and the peripheral (CSYSACK).\n- Normal clocked operation: CSYSREQ=1 and CSYSACK=1.\n- Low-power state: CSYSREQ=0 and CSYSACK=0. (CACTIVE is 0 if the request was accepted.)\n- The protocol requires the paired transitions: CSYSREQ low must be followed by CSYSACK low; CSYSREQ high must be followed by CSYSACK high. A new request must not start until the previous handshake has completed (both back high).\n\nCSYSREQ (driven by system clock controller)\n- Request entry to low-power: drive CSYSREQ=0 and hold it until the peripheral responds by driving CSYSACK=0.\n- Request/confirm exit from low-power: drive CSYSREQ=1 and hold it until the peripheral responds by driving CSYSACK=1.\n- If the peripheral initiated the exit by asserting CACTIVE, immediately enable the clock and then drive CSYSREQ=1 to complete the handshake.\n- If a low-power entry was denied (peripheral kept CACTIVE=1 while asserting CSYSACK=0), the controller must still complete the handshake by re-asserting CSYSREQ=1 and waiting for CSYSACK=1 before issuing another request.\n\nCSYSACK (driven by peripheral)\n- Acknowledge entry request: after detecting CSYSREQ=0, drive CSYSACK=0.\n  - Acceptance vs denial is indicated by CACTIVE at the time CSYSACK goes low:\n    - CACTIVE=0 \u2192 request accepted (peripheral may first perform its power-down, then drop CSYSACK).\n    - CACTIVE=1 \u2192 request denied (no power-down). Controller must finish the handshake by returning CSYSREQ high.\n- Acknowledge exit request: after detecting CSYSREQ=1, drive CSYSACK=1. The peripheral may delay asserting CSYSACK until its power-up sequence completes.\n- During peripheral-initiated exit, assert CACTIVE=1 first; after the controller drives CSYSREQ=1, assert CSYSACK=1 to finish the sequence.\n\nNotes for multi-peripheral low-power domains\n- A single CSYSREQ can fan out to all peripherals.\n- Domain CSYSACK low occurs when all peripherals have driven CSYSACK low; domain CSYSACK high occurs when all have driven it high."
    },
    {
        "protocol": "WISHBONE data transfer",
        "candidates": "../../test_cases/WISHBONE/data_transfer/sat_filtered_NL.json",
        "textual_description": "Scope: WISHBONE Classic bus cycles; ERR_I/RTY_I are not used. ACK_I is the only terminator. All outputs are registered on the rising edge of CLK_I; inputs must be stable before the rising edge.\n\nCYC_O (Cycle)\n- Must be asserted for the entire duration of a SINGLE/BLOCK/RMW classic cycle.\n- Must be asserted no later than the rising CLK edge that qualifies the assertion of STB_O.\n- Must be negated no earlier than the rising CLK edge that qualifies the negation of STB_O.\n- Recommendation: do not hold CYC_O asserted indefinitely.\n- If the master never inserts wait states, CYC_O may be the same signal as STB_O (both ports still present).\n\nSTB_O (Strobe)\n- Assert to start a transfer phase when ready.\n- Keep asserted until the master samples ACK_I = 1 at a rising CLK edge.\n- Negate on the clock edge following the sampled assertion of ACK_I.\n- May be negated between phases to insert master wait states; re-assert to continue the next phase while CYC_O stays high.\n- Must qualify (i.e., be high whenever valid values are driven on) ADR_O, DAT_O, WE_O, and SEL_O.\n\nACK_I (Acknowledge)\n- Indicates normal termination of the current transfer phase.\n- Master samples at every rising CLK edge; when sampled high, the phase completes:\n  - master latches DAT_I (READ) or knows the SLAVE has accepted DAT_O (WRITE),\n  - master negates STB_O next cycle; if this was the last phase, it also negates CYC_O.\n- Slave generates ACK_O in response to CYC_I AND STB_I; may be asserted asynchronously and is asserted/negated in response to STB_I.\n- Master must operate correctly even if a slave holds ACK_I continuously asserted.\n\nADR_O (Address)\n- Must be valid and stable whenever STB_O is asserted; may change for the next phase after the current phase is completed (i.e., after ACK_I is sampled).\n- For BLOCK cycles, a new ADR_O may be presented for the next phase while CYC_O remains asserted.\n\nDAT_I (Read data, input to master)\n- Considered valid only with ACK_I; master latches DAT_I on the rising CLK edge where ACK_I is sampled high.\n- May be undefined in cycles or phases until ACK_I is asserted.\n\nDAT_O (Write data, output from master)\n- Must be valid and stable whenever STB_O is asserted during WRITE phases; slave latches on the rising CLK edge where it asserts ACK_O (seen as ACK_I by the master).\n- May change for the next phase after the current phase completes.\n\nWE_O (Write enable)\n- 0 = READ, 1 = WRITE.\n- Must be valid and stable whenever STB_O is asserted and remain stable for the phase until ACK_I is sampled.\n\nSEL_O (Byte enables)\n- Indicates active byte lanes for the transfer.\n- Must be valid and stable whenever STB_O is asserted and remain stable for the phase until ACK_I is sampled.\n\nAdditional handshake behavior\n- Slave-inserted wait states: the slave throttles by withholding ACK_O; master keeps STB_O asserted until ACK_I is sampled.\n- Master-inserted wait states: master throttles by negating STB_O between phases while keeping CYC_O asserted (BLOCK/RMW cycles)."
    },
    {
        "protocol": "WISHBONE reset",
        "candidates": "../../test_cases/WISHBONE/reset/sat_filtered_NL.json",
        "textual_description": "WISHBONE Classic reset operation \u2013 rules for RST_I, STB_O, CYC_O\n\nRST_I (Reset input)\n- Minimum assertion: MUST be asserted for at least one complete clock cycle (Rule 3.05).\n- Duration: MAY be asserted for more than one cycle and MAY be asserted indefinitely (Permission 3.00).\n- Reaction timing: All interfaces MUST initialize at the rising CLK_I edge following the assertion of RST_I, and MUST remain initialized until the rising CLK_I edge that follows the negation of RST_I (Rule 3.00).\n- Responsiveness: All interfaces MUST be capable of reacting to RST_I at any time (Rule 3.10).\n- State machines/counters: All self-starting state machines and counters MUST initialize at the rising CLK_I edge following assertion of RST_I and remain initialized until the rising edge after negation of RST_I (Rule 3.15).\n\nSTB_O (Master strobe output)\n- During reset: MUST be negated at the rising CLK_I edge following assertion of RST_I and MUST stay negated until the rising CLK_I edge that follows the negation of RST_I (Rule 3.20).\n- After reset release: MAY be asserted beginning at the first rising CLK_I edge after RST_I is negated (Observation 3.05 / Fig. 3-1 note).\n\nCYC_O (Master cycle output)\n- During reset: MUST be negated at the rising CLK_I edge following assertion of RST_I and MUST stay negated until the rising CLK_I edge that follows the negation of RST_I (Rule 3.20).\n- After reset release: MAY be asserted beginning at the first rising CLK_I edge after RST_I is negated (Observation 3.05 / Fig. 3-1 note)."
    },
    {
        "protocol": "APB transfers",
        "candidates": "../../test_cases/APB/transfers/sat_filtered_NL.json",
        "textual_description": "APB write/read transfer rules for: PADDR, PSEL, PENABLE, PWRITE, PWDATA, PREADY, PRDATA\n\nGeneral\n- All APB signals are sampled on the rising edge of PCLK.\n- A transfer has two phases: SETUP (one cycle) then ACCESS (one or more cycles).\n- A transfer completes in the cycle where PSEL=1, PENABLE=1, and PREADY=1.\n- While a transfer is being extended (PENABLE=1 and PREADY=0), the following must remain unchanged: PADDR, PWRITE, PSEL, PENABLE, PWDATA (writes), and any other control/user signals.\n\nPADDR (Requester \u2192 Completer)\n- Byte address; may be unaligned but behavior is UNPREDICTABLE if unaligned.\n- Must be valid when PSEL=1 (SETUP).\n- Must not change between SETUP and ACCESS, nor in any ACCESS cycle.\n- Remains stable while PREADY=0.\n- Sampled at completion of the transfer.\n\nPSEL (Requester \u2192 Completer)\n- 1 selects the target Completer and starts the SETUP phase; 0 indicates IDLE.\n- Must always be driven to a valid 0/1 level.\n- Assert for SETUP; keep asserted through ACCESS.\n- Deassert after completion unless another transfer to the same Completer follows (in which case the interface can go directly to the next SETUP).\n\nPENABLE (Requester \u2192 Completer)\n- 0 in SETUP; 1 in ACCESS (asserted the cycle after PSEL is asserted).\n- Must not change during ACCESS.\n- Deasserted at the end of the transfer.\n\nPWRITE (Requester \u2192 Completer)\n- 1 = write transfer; 0 = read transfer.\n- Must be valid in SETUP when PSEL=1.\n- Must not change from SETUP into ACCESS or while PREADY=0.\n\nPWDATA (Requester \u2192 Completer; write only)\n- Must be valid in SETUP when PSEL=1 and PWRITE=1 (active byte lanes only).\n- Must remain stable from SETUP through all ACCESS cycles until completion.\n- Not used in read transfers.\n\nPREADY (Completer \u2192 Requester)\n- Indicates completion/extension during ACCESS.\n- If PENABLE=1 and PREADY=1, the transfer completes in that cycle.\n- If PENABLE=1 and PREADY=0, the transfer is extended; all request/control signals listed above must remain unchanged.\n- Can take any value when PENABLE=0 (allows fixed two-cycle peripherals to tie PREADY high).\n- Must be valid when PSEL=1 and PENABLE=1.\n\nPRDATA (Completer \u2192 Requester; read only)\n- Must be valid in the completion cycle of a read: when PSEL=1, PENABLE=1, PREADY=1, and PWRITE=0.\n- Provided by the Completer before the end of the read transfer; sampled on completion."
    },
    {
        "protocol": "PCI transaction termination",
        "candidates": "../../test_cases/PCI/transaction_termination/sat_filtered_NL.json",
        "textual_description": "PCI transaction termination \u2013 signal interaction rules\n\nGeneral\n- A data phase completes on any rising clock edge where IRDY# is asserted and either TRDY# or STOP# is asserted. If TRDY# is asserted, data transfers; if only STOP# is asserted, no data transfers in that phase.\n- The bus returns to Idle when both FRAME# and IRDY# are deasserted.\n\nFRAME#\n- Master asserts FRAME# to start a transaction. To terminate, the master deasserts FRAME# while asserting IRDY#; this makes the current phase the final one.\n- FRAME# cannot be deasserted unless IRDY# is asserted. Once deasserted, it cannot be reasserted in the same transaction.\n- Once the master has asserted IRDY#, it cannot change FRAME# until the current data phase completes.\n- If the target asserts STOP#, the master must deassert FRAME# as soon as it can assert IRDY#.\n- Master\u2011Abort: if no target asserts DEVSEL# by the allowed decode window (up to clock 5 from the first assertion of FRAME#), the master terminates with Master\u2011Abort by deasserting FRAME# and then IRDY#. Earliest termination is five clocks after FRAME# was first asserted.\n- Timeout termination: when the master\u2019s Latency Timer expires and GNT# is deasserted, the master must deassert FRAME# and end the transaction at the next legal phase boundary (for Memory Write and Invalidate, at a cacheline boundary).\n\nIRDY#\n- Asserted by the master when ready for the current data phase.\n- A data phase completes on a clock where IRDY# and TRDY# are both asserted or IRDY# and STOP# are both asserted.\n- Once asserted, IRDY# cannot change until the current data phase completes.\n- In the last phase, the master asserts IRDY# and deasserts FRAME#; IRDY# must remain asserted until the last transfer occurs, then be deasserted on the next clock.\n\nTRDY#\n- Asserted by the target when it can complete the current data phase; cannot be driven until DEVSEL# is asserted.\n- Once the target has asserted TRDY# (or STOP#), it cannot change TRDY#, STOP#, or DEVSEL# until the current data phase completes.\n- With IRDY# asserted, TRDY# causes a data transfer. With STOP# asserted at the same time, it is a Disconnect with Data (only the current phase completes).\n- TRDY# must be deasserted the clock following completion of the last data phase and tri\u2011stated on the next clock.\n\nSTOP#\n- Asserted by the target to request termination.\n- Retry (busy, no data): on the initial data phase only, the target asserts STOP# and does not assert TRDY# (STOP# cannot be asserted during the address\u2011to\u2011data turn\u2011around of a read). Master must repeat the request unconditionally.\n- Disconnect With Data: target asserts STOP# and TRDY# together; only the current data phase completes, then the master must end the transaction.\n- Disconnect Without Data: on a subsequent phase (i.e., data was transferred in the previous phase), the target deasserts TRDY# and asserts STOP#; the current phase completes without transferring data.\n- Once asserted, STOP# must remain asserted until FRAME# is deasserted, after which STOP# is deasserted on the next clock.\n\nDEVSEL#\n- Asserted by the target when it positively decodes the address; asserted in fast/medium/slow windows (1/2/3 clocks). If no device asserts DEVSEL# by the allowed window (up to clock 5), the master must terminate with Master\u2011Abort.\n- During a data phase, once the target has asserted TRDY# or STOP#, DEVSEL# cannot change until that data phase completes.\n- Target\u2011Abort: an abnormal termination signaled by deasserting DEVSEL# and asserting STOP# in the same clock.\n- DEVSEL#, TRDY#, and STOP# must all be deasserted the clock after the last data phase completes and tri\u2011stated on the following clock."
    }
]